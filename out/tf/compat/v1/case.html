
    <html lang="zh-cn">
    <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <link href=../../../../default.css" rel="stylesheet">
    <link href="
   ../../../../github.css" rel="stylesheet">
    </head>
    <body>
    <div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.compat.v1.case" />
<meta itemprop="path" content="Stable" />
</div>

<h1 id="tfcompatv1case">tf.compat.v1.case</h1>
<!-- Insert buttons -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<p><a target="_blank" href="/code/stable/tensorflow/python/ops/control_flow_ops.py">View source</a></p>
<!-- Start diff -->

<p>Create a case operation.</p>
<div class="codehilite"><pre><span></span><span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">case</span><span class="p">(</span>
    <span class="n">pred_fn_pairs</span><span class="p">,</span>
    <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">exclusive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;case&#39;</span>
<span class="p">)</span>
</pre></div>


<!-- Placeholder for "Used in" -->

<p>See also <a href="../../../tf/switch_case.html"><code>tf.switch_case</code></a>.</p>
<p>The <code>pred_fn_pairs</code> parameter is a dict or list of pairs of size N.
Each pair contains a boolean scalar tensor and a python callable that
creates the tensors to be returned if the boolean evaluates to True.
<code>default</code> is a callable generating a list of tensors. All the callables
in <code>pred_fn_pairs</code> as well as <code>default</code> (if provided) should return the same
number and types of tensors.</p>
<p>If <code>exclusive==True</code>, all predicates are evaluated, and an exception is
thrown if more than one of the predicates evaluates to <code>True</code>.
If <code>exclusive==False</code>, execution stops at the first predicate which
evaluates to True, and the tensors generated by the corresponding function
are returned immediately. If none of the predicates evaluate to True, this
operation returns the tensors generated by <code>default</code>.</p>
<p><a href="../../../tf/case.html"><code>tf.case</code></a> supports nested structures as implemented in
<code>tf.contrib.framework.nest</code>. All of the callables must return the same
(possibly nested) value structure of lists, tuples, and/or named tuples.
Singleton lists and tuples form the only exceptions to this: when returned by
a callable, they are implicitly unpacked to single values. This
behavior is disabled by passing <code>strict=True</code>.</p>
<p>If an unordered dictionary is used for <code>pred_fn_pairs</code>, the order of the
conditional tests is not guaranteed. However, the order is guaranteed to be
deterministic, so that variables created in conditional branches are created
in fixed order across runs.</p>
<p><strong>Example 1:</strong></p>
<h4 id="pseudocode">Pseudocode:</h4>
<div class="codehilite"><pre><span></span><span class="err">if (x &lt; y) return 17;</span>
<span class="err">else return 23;</span>
</pre></div>


<h4 id="expressions">Expressions:</h4>
<div class="codehilite"><pre><span></span><span class="n">f1</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">case</span><span class="p">([(</span><span class="n">tf</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">f1</span><span class="p">)],</span> <span class="n">default</span><span class="o">=</span><span class="n">f2</span><span class="p">)</span>
</pre></div>


<p><strong>Example 2:</strong></p>
<h4 id="pseudocode_1">Pseudocode:</h4>
<div class="codehilite"><pre><span></span><span class="err">if (x &lt; y &amp;&amp; x &gt; z) raise OpError(&quot;Only one predicate may evaluate to True&quot;);</span>
<span class="err">if (x &lt; y) return 17;</span>
<span class="err">else if (x &gt; z) return 23;</span>
<span class="err">else return -1;</span>
</pre></div>


<h4 id="expressions_1">Expressions:</h4>
<div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">f1</span><span class="p">():</span> <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f2</span><span class="p">():</span> <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mi">23</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">f3</span><span class="p">():</span> <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">case</span><span class="p">({</span><span class="n">tf</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span> <span class="n">f1</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span> <span class="n">f2</span><span class="p">},</span>
         <span class="n">default</span><span class="o">=</span><span class="n">f3</span><span class="p">,</span> <span class="n">exclusive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>


<h4 id="args">Args:</h4>
<ul>
<li><b><code>pred_fn_pairs</code></b>: Dict or list of pairs of a boolean scalar tensor and a
  callable which returns a list of tensors.</li>
<li><b><code>default</code></b>: Optional callable that returns a list of tensors.</li>
<li><b><code>exclusive</code></b>: True iff at most one predicate is allowed to evaluate to <code>True</code>.</li>
<li><b><code>strict</code></b>: A boolean that enables/disables 'strict' mode; see above.</li>
<li><b><code>name</code></b>: A name for this operation (optional).</li>
</ul>
<h4 id="returns">Returns:</h4>
<p>The tensors returned by the first pair whose predicate evaluated to True, or
those returned by <code>default</code> if none does.</p>
<h4 id="raises">Raises:</h4>
<ul>
<li><b><code>TypeError</code></b>: If <code>pred_fn_pairs</code> is not a list/dictionary.</li>
<li><b><code>TypeError</code></b>: If <code>pred_fn_pairs</code> is a list but does not contain 2-tuples.</li>
<li><b><code>TypeError</code></b>: If <code>fns[i]</code> is not callable for any i, or <code>default</code> is not
           callable.</li>
</ul>
<h4 id="eager-compatibility">Eager Compatibility</h4>
<p>Unordered dictionaries are not supported in eager mode when <code>exclusive=False</code>.
Use a list of tuples instead.</p>
    </body>
    </html>
   