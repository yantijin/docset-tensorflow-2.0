
    <html lang="zh-cn">
    <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <link href="../../../../../default.css" rel="stylesheet">
    <link href="
   ../../../../../github.css" rel="stylesheet">
    </head>
    <body>
    <div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.compat.v1.data.TextLineDataset" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="element_spec"/>
<meta itemprop="property" content="output_classes"/>
<meta itemprop="property" content="output_shapes"/>
<meta itemprop="property" content="output_types"/>
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="__iter__"/>
<meta itemprop="property" content="apply"/>
<meta itemprop="property" content="batch"/>
<meta itemprop="property" content="cache"/>
<meta itemprop="property" content="concatenate"/>
<meta itemprop="property" content="enumerate"/>
<meta itemprop="property" content="filter"/>
<meta itemprop="property" content="filter_with_legacy_function"/>
<meta itemprop="property" content="flat_map"/>
<meta itemprop="property" content="from_generator"/>
<meta itemprop="property" content="from_sparse_tensor_slices"/>
<meta itemprop="property" content="from_tensor_slices"/>
<meta itemprop="property" content="from_tensors"/>
<meta itemprop="property" content="interleave"/>
<meta itemprop="property" content="list_files"/>
<meta itemprop="property" content="make_initializable_iterator"/>
<meta itemprop="property" content="make_one_shot_iterator"/>
<meta itemprop="property" content="map"/>
<meta itemprop="property" content="map_with_legacy_function"/>
<meta itemprop="property" content="options"/>
<meta itemprop="property" content="padded_batch"/>
<meta itemprop="property" content="prefetch"/>
<meta itemprop="property" content="range"/>
<meta itemprop="property" content="reduce"/>
<meta itemprop="property" content="repeat"/>
<meta itemprop="property" content="shard"/>
<meta itemprop="property" content="shuffle"/>
<meta itemprop="property" content="skip"/>
<meta itemprop="property" content="take"/>
<meta itemprop="property" content="unbatch"/>
<meta itemprop="property" content="window"/>
<meta itemprop="property" content="with_options"/>
<meta itemprop="property" content="zip"/>
</div>

<h1 id="tfcompatv1datatextlinedataset">tf.compat.v1.data.TextLineDataset</h1>
<!-- Insert buttons -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/readers.py">View source</a></p>
<h2 id="class-textlinedataset">Class <code>TextLineDataset</code></h2>
<!-- Start diff -->

<p>A <code>Dataset</code> comprising lines from one or more text files.</p>
<!-- Placeholder for "Used in" -->

<h2 id="__init__"><code>__init__</code></h2>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/readers.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="fm">__init__</span><span class="p">(</span>
    <span class="n">filenames</span><span class="p">,</span>
    <span class="n">compression_type</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">buffer_size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">num_parallel_reads</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Creates a <code>TextLineDataset</code>.</p>
<h4 id="args">Args:</h4>
<ul>
<li><b><code>filenames</code></b>: A <a href="../../../../tf.html#string"><code>tf.string</code></a> tensor or <a href="../../../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> containing one or
  more filenames.</li>
<li><b><code>compression_type</code></b>: (Optional.) A <a href="../../../../tf.html#string"><code>tf.string</code></a> scalar evaluating to one of
  <code>""</code> (no compression), <code>"ZLIB"</code>, or <code>"GZIP"</code>.</li>
<li><b><code>buffer_size</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar denoting the number of bytes
  to buffer. A value of 0 results in the default buffering values chosen
  based on the compression type.</li>
<li><b><code>num_parallel_reads</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar representing the
  number of files to read in parallel. If greater than one, the records of
  files read in parallel are outputted in an interleaved order. If your
  input pipeline is I/O bottlenecked, consider setting this parameter to a
  value greater than one to parallelize the I/O. If <code>None</code>, files will be
  read sequentially.</li>
</ul>
<h2 id="properties">Properties</h2>
<h3 id="element_spec"><code>element_spec</code></h3>

<p>The type specification of an element of this dataset.</p>
<h4 id="returns">Returns:</h4>
<p>A nested structure of <a href="../../../../tf/TypeSpec.html"><code>tf.TypeSpec</code></a> objects matching the structure of an
element of this dataset and specifying the type of individual components.</p>
<h3 id="output_classes"><code>output_classes</code></h3>

<p>Returns the class of each component of an element of this dataset. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/compat/v1/data/get_output_classes.html"><code>tf.compat.v1.data.get_output_classes(dataset)</code></a>.</p>
<h4 id="returns_1">Returns:</h4>
<p>A nested structure of Python <code>type</code> objects corresponding to each
component of an element of this dataset.</p>
<h3 id="output_shapes"><code>output_shapes</code></h3>

<p>Returns the shape of each component of an element of this dataset. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/compat/v1/data/get_output_shapes.html"><code>tf.compat.v1.data.get_output_shapes(dataset)</code></a>.</p>
<h4 id="returns_2">Returns:</h4>
<p>A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> objects corresponding to each
component of an element of this dataset.</p>
<h3 id="output_types"><code>output_types</code></h3>

<p>Returns the type of each component of an element of this dataset. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/compat/v1/data/get_output_types.html"><code>tf.compat.v1.data.get_output_types(dataset)</code></a>.</p>
<h4 id="returns_3">Returns:</h4>
<p>A nested structure of <a href="../../../../tf/dtypes/DType.html"><code>tf.DType</code></a> objects corresponding to each component
of an element of this dataset.</p>
<h2 id="methods">Methods</h2>
<h3 id="__iter__"><code>__iter__</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="fm">__iter__</span><span class="p">()</span>
</pre></div>


<p>Creates an <code>Iterator</code> for enumerating the elements of this dataset.</p>
<p>The returned iterator implements the Python iterator protocol and therefore
can only be used in eager mode.</p>
<h4 id="returns_4">Returns:</h4>
<p>An <code>Iterator</code> over the elements of this dataset.</p>
<h4 id="raises">Raises:</h4>
<ul>
<li><b><code>RuntimeError</code></b>: If not inside of tf.function and not executing eagerly.</li>
</ul>
<h3 id="apply"><code>apply</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">apply</span><span class="p">(</span><span class="n">transformation_func</span><span class="p">)</span>
</pre></div>


<p>Applies a transformation function to this dataset.</p>
<p><code>apply</code> enables chaining of custom <code>Dataset</code> transformations, which are
represented as functions that take one <code>Dataset</code> argument and return a
transformed <code>Dataset</code>.</p>
<h4 id="for-example">For example:</h4>
<div class="codehilite"><pre><span></span><span class="err">dataset = (dataset.map(lambda x: x ** 2)</span>
<span class="err">           .apply(group_by_window(key_func, reduce_func, window_size))</span>
<span class="err">           .map(lambda x: x ** 3))</span>
</pre></div>


<h4 id="args_1">Args:</h4>
<ul>
<li><b><code>transformation_func</code></b>: A function that takes one <code>Dataset</code> argument and
  returns a <code>Dataset</code>.</li>
</ul>
<h4 id="returns_5">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: The <code>Dataset</code> returned by applying <code>transformation_func</code> to this
    dataset.</li>
</ul>
<h3 id="batch"><code>batch</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">batch</span><span class="p">(</span>
    <span class="n">batch_size</span><span class="p">,</span>
    <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>


<p>Combines consecutive elements of this dataset into batches.</p>
<p>The components of the resulting element will have an additional outer
dimension, which will be <code>batch_size</code> (or <code>N % batch_size</code> for the last
element if <code>batch_size</code> does not divide the number of input elements <code>N</code>
evenly and <code>drop_remainder</code> is <code>False</code>). If your program depends on the
batches having the same outer dimension, you should set the <code>drop_remainder</code>
argument to <code>True</code> to prevent the smaller batch from being produced.</p>
<h4 id="args_2">Args:</h4>
<ul>
<li><b><code>batch_size</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of
  consecutive elements of this dataset to combine in a single batch.</li>
<li><b><code>drop_remainder</code></b>: (Optional.) A <a href="../../../../tf.html#bool"><code>tf.bool</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing
  whether the last batch should be dropped in the case it has fewer than
  <code>batch_size</code> elements; the default behavior is not to drop the smaller
  batch.</li>
</ul>
<h4 id="returns_6">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="cache"><code>cache</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">cache</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
</pre></div>


<p>Caches the elements in this dataset.</p>
<h4 id="args_3">Args:</h4>
<ul>
<li><b><code>filename</code></b>: A <a href="../../../../tf.html#string"><code>tf.string</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the name of a
  directory on the filesystem to use for caching elements in this Dataset.
  If a filename is not provided, the dataset will be cached in memory.</li>
</ul>
<h4 id="returns_7">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="concatenate"><code>concatenate</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">concatenate</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> by concatenating the given dataset with this dataset.</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 1, 2, 3 ]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 4, 5, 6, 7 ]</span>

<span class="c1"># The input dataset and dataset to be concatenated should have the same</span>
<span class="c1"># nested structures and output types.</span>
<span class="c1"># c = Dataset.range(8, 14).batch(2)  # ==&gt; [ [8, 9], [10, 11], [12, 13] ]</span>
<span class="c1"># d = Dataset.from_tensor_slices([14.0, 15.0, 16.0])</span>
<span class="c1"># a.concatenate(c) and a.concatenate(d) would result in error.</span>

<span class="n">a</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 1, 2, 3, 4, 5, 6, 7 ]</span>
</pre></div>


<h4 id="args_4">Args:</h4>
<ul>
<li><b><code>dataset</code></b>: <code>Dataset</code> to be concatenated.</li>
</ul>
<h4 id="returns_8">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="enumerate"><code>enumerate</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="nb">enumerate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>


<p>Enumerates the elements of this dataset.</p>
<p>It is similar to python's <code>enumerate</code>.</p>
<h4 id="for-example_1">For example:</h4>
<div class="codehilite"><pre><span></span><span class="c1"># NOTE: The following examples use `{ ... }` to represent the</span>
<span class="c1"># contents of a dataset.</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">}</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="p">}</span>

<span class="c1"># The nested structure of the `datasets` argument determines the</span>
<span class="c1"># structure of elements in the resulting dataset.</span>
<span class="n">a</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span> <span class="o">==</span> <span class="p">{</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="p">}</span>
<span class="n">b</span><span class="o">.</span><span class="n">enumerate</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="p">}</span>
</pre></div>


<h4 id="args_5">Args:</h4>
<ul>
<li><b><code>start</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the start value for
  enumeration.</li>
</ul>
<h4 id="returns_9">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="filter"><code>filter</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="nb">filter</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>
</pre></div>


<p>Filters this dataset according to <code>predicate</code>.</p>
<div class="codehilite"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># ==&gt; [1, 2]</span>

<span class="c1"># `tf.math.equal(x, y)` is required for equality comparison</span>
<span class="k">def</span> <span class="nf">filter_fn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">filter_fn</span><span class="p">)</span>  <span class="c1"># ==&gt; [1]</span>
</pre></div>


<h4 id="args_6">Args:</h4>
<ul>
<li><b><code>predicate</code></b>: A function mapping a dataset element to a boolean.</li>
</ul>
<h4 id="returns_10">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: The <code>Dataset</code> containing the elements of this dataset for which
    <code>predicate</code> is <code>True</code>.</li>
</ul>
<h3 id="filter_with_legacy_function"><code>filter_with_legacy_function</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">filter_with_legacy_function</span><span class="p">(</span><span class="n">predicate</span><span class="p">)</span>
</pre></div>


<p>Filters this dataset according to <code>predicate</code>. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use `tf.data.Dataset.filter()</p>
<p>NOTE: This is an escape hatch for existing uses of <code>filter</code> that do not work
with V2 functions. New uses are strongly discouraged and existing uses
should migrate to <code>filter</code> as this method will be removed in V2.</p>
<h4 id="args_7">Args:</h4>
<ul>
<li><b><code>predicate</code></b>: A function mapping a nested structure of tensors (having shapes
  and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to a
  scalar <a href="../../../../tf.html#bool"><code>tf.bool</code></a> tensor.</li>
</ul>
<h4 id="returns_11">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: The <code>Dataset</code> containing the elements of this dataset for which
    <code>predicate</code> is <code>True</code>.</li>
</ul>
<h3 id="flat_map"><code>flat_map</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">flat_map</span><span class="p">(</span><span class="n">map_func</span><span class="p">)</span>
</pre></div>


<p>Maps <code>map_func</code> across this dataset and flattens the result.</p>
<p>Use <code>flat_map</code> if you want to make sure that the order of your dataset
stays the same. For example, to flatten a dataset of batches into a
dataset of their elements:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">([</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span> <span class="p">])</span>

<span class="n">a</span><span class="o">.</span><span class="n">flat_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># ==&gt;</span>
<span class="c1">#  [ 2, 3, 4, 5, 6, 7, 8, 9, 10 ]</span>
</pre></div>


<p><a href="../../../../tf/data/Dataset.html#interleave"><code>tf.data.Dataset.interleave()</code></a> is a generalization of <code>flat_map</code>, since
<code>flat_map</code> produces the same output as
<a href="../../../../tf/data/Dataset.html#interleave"><code>tf.data.Dataset.interleave(cycle_length=1)</code></a></p>
<h4 id="args_8">Args:</h4>
<ul>
<li><b><code>map_func</code></b>: A function mapping a dataset element to a dataset.</li>
</ul>
<h4 id="returns_12">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="from_generator"><code>from_generator</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">from_generator</span><span class="p">(</span>
    <span class="n">generator</span><span class="p">,</span>
    <span class="n">output_types</span><span class="p">,</span>
    <span class="n">output_shapes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">args</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> whose elements are generated by <code>generator</code>.</p>
<p>The <code>generator</code> argument must be a callable object that returns
an object that supports the <code>iter()</code> protocol (e.g. a generator function).
The elements generated by <code>generator</code> must be compatible with the given
<code>output_types</code> and (optional) <code>output_shapes</code> arguments.</p>
<h4 id="for-example_2">For example:</h4>
<div class="codehilite"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span>
<span class="n">tf</span><span class="o">.</span><span class="n">compat</span><span class="o">.</span><span class="n">v1</span><span class="o">.</span><span class="n">enable_eager_execution</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">gen</span><span class="p">():</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">yield</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_generator</span><span class="p">(</span>
    <span class="n">gen</span><span class="p">,</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">int64</span><span class="p">),</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([]),</span> <span class="n">tf</span><span class="o">.</span><span class="n">TensorShape</span><span class="p">([</span><span class="kc">None</span><span class="p">])))</span>

<span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">ds</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
  <span class="nb">print</span> <span class="n">value</span>
<span class="c1"># (1, array([1]))</span>
<span class="c1"># (2, array([1, 1]))</span>
</pre></div>


<p>NOTE: The current implementation of <code>Dataset.from_generator()</code> uses
<a href="../../../../tf/numpy_function.html"><code>tf.numpy_function</code></a> and inherits the same constraints. In particular, it
requires the <code>Dataset</code>- and <code>Iterator</code>-related operations to be placed
on a device in the same process as the Python program that called
<code>Dataset.from_generator()</code>. The body of <code>generator</code> will not be
serialized in a <code>GraphDef</code>, and you should not use this method if you
need to serialize your model and restore it in a different environment.</p>
<p>NOTE: If <code>generator</code> depends on mutable global variables or other external
state, be aware that the runtime may invoke <code>generator</code> multiple times
(in order to support repeating the <code>Dataset</code>) and at any time
between the call to <code>Dataset.from_generator()</code> and the production of the
first element from the generator. Mutating global variables or external
state can cause undefined behavior, and we recommend that you explicitly
cache any external state in <code>generator</code> before calling
<code>Dataset.from_generator()</code>.</p>
<h4 id="args_9">Args:</h4>
<ul>
<li><b><code>generator</code></b>: A callable object that returns an object that supports the
  <code>iter()</code> protocol. If <code>args</code> is not specified, <code>generator</code> must take no
  arguments; otherwise it must take as many arguments as there are values
  in <code>args</code>.</li>
<li><b><code>output_types</code></b>: A nested structure of <a href="../../../../tf/dtypes/DType.html"><code>tf.DType</code></a> objects corresponding to
  each component of an element yielded by <code>generator</code>.</li>
<li><b><code>output_shapes</code></b>: (Optional.) A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> objects
  corresponding to each component of an element yielded by <code>generator</code>.</li>
<li><b><code>args</code></b>: (Optional.) A tuple of <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> objects that will be evaluated
  and passed to <code>generator</code> as NumPy-array arguments.</li>
</ul>
<h4 id="returns_13">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="from_sparse_tensor_slices"><code>from_sparse_tensor_slices</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">from_sparse_tensor_slices</span><span class="p">(</span><span class="n">sparse_tensor</span><span class="p">)</span>
</pre></div>


<p>Splits each rank-N <a href="../../../../tf/sparse/SparseTensor.html"><code>tf.SparseTensor</code></a> in this dataset row-wise. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/data/Dataset.html#from_tensor_slices"><code>tf.data.Dataset.from_tensor_slices()</code></a>.</p>
<h4 id="args_10">Args:</h4>
<ul>
<li><b><code>sparse_tensor</code></b>: A <a href="../../../../tf/sparse/SparseTensor.html"><code>tf.SparseTensor</code></a>.</li>
</ul>
<h4 id="returns_14">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code> of rank-(N-1) sparse tensors.</li>
</ul>
<h3 id="from_tensor_slices"><code>from_tensor_slices</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">from_tensor_slices</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> whose elements are slices of the given tensors.</p>
<p>Note that if <code>tensors</code> contains a NumPy array, and eager execution is not
enabled, the values will be embedded in the graph as one or more
<a href="../../../../tf/constant.html"><code>tf.constant</code></a> operations. For large datasets (&gt; 1 GB), this can waste
memory and run into byte limits of graph serialization. If <code>tensors</code>
contains one or more large NumPy arrays, consider the alternative described
in <a href="https://tensorflow.org/guide/datasets#consuming_numpy_arrays">this guide</a>.</p>
<h4 id="args_11">Args:</h4>
<ul>
<li><b><code>tensors</code></b>: A dataset element, with each component having the same size in
  the 0th dimension.</li>
</ul>
<h4 id="returns_15">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="from_tensors"><code>from_tensors</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">from_tensors</span><span class="p">(</span><span class="n">tensors</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> with a single element, comprising the given tensors.</p>
<p>Note that if <code>tensors</code> contains a NumPy array, and eager execution is not
enabled, the values will be embedded in the graph as one or more
<a href="../../../../tf/constant.html"><code>tf.constant</code></a> operations. For large datasets (&gt; 1 GB), this can waste
memory and run into byte limits of graph serialization. If <code>tensors</code>
contains one or more large NumPy arrays, consider the alternative described
in <a href="https://tensorflow.org/guide/datasets#consuming_numpy_arrays">this
guide</a>.</p>
<h4 id="args_12">Args:</h4>
<ul>
<li><b><code>tensors</code></b>: A dataset element.</li>
</ul>
<h4 id="returns_16">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="interleave"><code>interleave</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">interleave</span><span class="p">(</span>
    <span class="n">map_func</span><span class="p">,</span>
    <span class="n">cycle_length</span><span class="o">=</span><span class="n">AUTOTUNE</span><span class="p">,</span>
    <span class="n">block_length</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">num_parallel_calls</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Maps <code>map_func</code> across this dataset, and interleaves the results.</p>
<p>For example, you can use <code>Dataset.interleave()</code> to process many input files
concurrently:</p>
<div class="codehilite"><pre><span></span><span class="c1"># Preprocess 4 files concurrently, and interleave blocks of 16 records from</span>
<span class="c1"># each file.</span>
<span class="n">filenames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;/var/data/file1.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;/var/data/file2.txt&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
<span class="n">dataset</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span>
           <span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
               <span class="n">TextLineDataset</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">parse_fn</span><span class="p">,</span> <span class="n">num_parallel_calls</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
               <span class="n">cycle_length</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">16</span><span class="p">))</span>
</pre></div>


<p>The <code>cycle_length</code> and <code>block_length</code> arguments control the order in which
elements are produced. <code>cycle_length</code> controls the number of input elements
that are processed concurrently. If you set <code>cycle_length</code> to 1, this
transformation will handle one input element at a time, and will produce
identical results to <a href="../../../../tf/data/Dataset.html#flat_map"><code>tf.data.Dataset.flat_map</code></a>. In general,
this transformation will apply <code>map_func</code> to <code>cycle_length</code> input elements,
open iterators on the returned <code>Dataset</code> objects, and cycle through them
producing <code>block_length</code> consecutive elements from each iterator, and
consuming the next input element each time it reaches the end of an
iterator.</p>
<h4 id="for-example_3">For example:</h4>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 1, 2, 3, 4, 5 ]</span>

<span class="c1"># NOTE: New lines indicate &quot;block&quot; boundaries.</span>
<span class="n">a</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensors</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">6</span><span class="p">),</span>
            <span class="n">cycle_length</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  <span class="c1"># ==&gt; [1, 1, 1, 1,</span>
                                             <span class="c1">#      2, 2, 2, 2,</span>
                                             <span class="c1">#      1, 1,</span>
                                             <span class="c1">#      2, 2,</span>
                                             <span class="c1">#      3, 3, 3, 3,</span>
                                             <span class="c1">#      4, 4, 4, 4,</span>
                                             <span class="c1">#      3, 3,</span>
                                             <span class="c1">#      4, 4,</span>
                                             <span class="c1">#      5, 5, 5, 5,</span>
                                             <span class="c1">#      5, 5]</span>
</pre></div>


<p>NOTE: The order of elements yielded by this transformation is
deterministic, as long as <code>map_func</code> is a pure function. If
<code>map_func</code> contains any stateful operations, the order in which
that state is accessed is undefined.</p>
<h4 id="args_13">Args:</h4>
<ul>
<li><b><code>map_func</code></b>: A function mapping a dataset element to a dataset.</li>
<li><b><code>cycle_length</code></b>: (Optional.) The number of input elements that will be
  processed concurrently. If not specified, the value will be derived from
  the number of available CPU cores. If the <code>num_parallel_calls</code> argument
  is set to <a href="../../../../tf/data/experimental.html#AUTOTUNE"><code>tf.data.experimental.AUTOTUNE</code></a>, the <code>cycle_length</code> argument
  also identifies the maximum degree of parallelism.</li>
<li><b><code>block_length</code></b>: (Optional.) The number of consecutive elements to produce
  from each input element before cycling to another input element.</li>
<li><b><code>num_parallel_calls</code></b>: (Optional.) If specified, the implementation creates a
  threadpool, which is used to fetch inputs from cycle elements
  asynchronously and in parallel. The default behavior is to fetch inputs
  from cycle elements synchronously with no parallelism. If the value
  <a href="../../../../tf/data/experimental.html#AUTOTUNE"><code>tf.data.experimental.AUTOTUNE</code></a> is used, then the number of parallel
  calls is set dynamically based on available CPU.</li>
</ul>
<h4 id="returns_17">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="list_files"><code>list_files</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">list_files</span><span class="p">(</span>
    <span class="n">file_pattern</span><span class="p">,</span>
    <span class="n">shuffle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>A dataset of all files matching one or more glob patterns.</p>
<p>NOTE: The default behavior of this method is to return filenames in
a non-deterministic random shuffled order. Pass a <code>seed</code> or <code>shuffle=False</code>
to get results in a deterministic order.</p>
<h4 id="example">Example:</h4>
<p>If we had the following files on our filesystem:
  - /path/to/dir/a.txt
  - /path/to/dir/b.py
  - /path/to/dir/c.py
If we pass "/path/to/dir/*.py" as the directory, the dataset
would produce:
  - /path/to/dir/b.py
  - /path/to/dir/c.py</p>
<h4 id="args_14">Args:</h4>
<ul>
<li><b><code>file_pattern</code></b>: A string, a list of strings, or a <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> of string type
  (scalar or vector), representing the filename glob (i.e. shell wildcard)
  pattern(s) that will be matched.</li>
<li><b><code>shuffle</code></b>: (Optional.) If <code>True</code>, the file names will be shuffled randomly.
  Defaults to <code>True</code>.</li>
<li><b><code>seed</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the random
  seed that will be used to create the distribution. See
  <a href="../../../../tf/compat/v1/set_random_seed.html"><code>tf.compat.v1.set_random_seed</code></a> for behavior.</li>
</ul>
<h4 id="returns_18">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code> of strings corresponding to file names.</li>
</ul>
<h3 id="make_initializable_iterator"><code>make_initializable_iterator</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">make_initializable_iterator</span><span class="p">(</span><span class="n">shared_name</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>


<p>Creates an <code>Iterator</code> for enumerating the elements of this dataset. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <code>for ... in dataset:</code> to iterate over a dataset. If using <code>tf.estimator</code>, return the <code>Dataset</code> object directly from your input function. As a last resort, you can use <code>tf.compat.v1.data.make_initializable_iterator(dataset)</code>.</p>
<p>Note: The returned iterator will be in an uninitialized state,
and you must run the <code>iterator.initializer</code> operation before using it:</p>
<div class="codehilite"><pre><span></span><span class="n">dataset</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">iterator</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">make_initializable_iterator</span><span class="p">()</span>
<span class="c1"># ...</span>
<span class="n">sess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">iterator</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span>
</pre></div>


<h4 id="args_15">Args:</h4>
<ul>
<li><b><code>shared_name</code></b>: (Optional.) If non-empty, the returned iterator will be
  shared under the given name across multiple sessions that share the same
  devices (e.g. when using a remote server).</li>
</ul>
<h4 id="returns_19">Returns:</h4>
<p>An <code>Iterator</code> over the elements of this dataset.</p>
<h4 id="raises_1">Raises:</h4>
<ul>
<li><b><code>RuntimeError</code></b>: If eager execution is enabled.</li>
</ul>
<h3 id="make_one_shot_iterator"><code>make_one_shot_iterator</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">make_one_shot_iterator</span><span class="p">()</span>
</pre></div>


<p>Creates an <code>Iterator</code> for enumerating the elements of this dataset. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <code>for ... in dataset:</code> to iterate over a dataset. If using <code>tf.estimator</code>, return the <code>Dataset</code> object directly from your input function. As a last resort, you can use <code>tf.compat.v1.data.make_one_shot_iterator(dataset)</code>.</p>
<p>Note: The returned iterator will be initialized automatically.
A "one-shot" iterator does not currently support re-initialization.</p>
<h4 id="returns_20">Returns:</h4>
<p>An <code>Iterator</code> over the elements of this dataset.</p>
<h3 id="map"><code>map</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="nb">map</span><span class="p">(</span>
    <span class="n">map_func</span><span class="p">,</span>
    <span class="n">num_parallel_calls</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Maps <code>map_func</code> across the elements of this dataset.</p>
<p>This transformation applies <code>map_func</code> to each element of this dataset, and
returns a new dataset containing the transformed elements, in the same
order as they appeared in the input.</p>
<h4 id="for-example_4">For example:</h4>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 1, 2, 3, 4, 5 ]</span>

<span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 2, 3, 4, 5, 6 ]</span>
</pre></div>


<p>The input signature of <code>map_func</code> is determined by the structure of each
element in this dataset. For example:</p>
<div class="codehilite"><pre><span></span><span class="c1"># NOTE: The following examples use `{ ... }` to represent the</span>
<span class="c1"># contents of a dataset.</span>
<span class="c1"># Each element is a `tf.Tensor` object.</span>
<span class="n">a</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span> <span class="p">}</span>
<span class="c1"># `map_func` takes a single argument of type `tf.Tensor` with the same</span>
<span class="c1"># shape and dtype.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span>

<span class="c1"># Each element is a tuple containing two `tf.Tensor` objects.</span>
<span class="n">b</span> <span class="o">=</span> <span class="p">{</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;foo&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;baz&quot;</span><span class="p">)</span> <span class="p">}</span>
<span class="c1"># `map_func` takes two arguments of type `tf.Tensor`.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x_int</span><span class="p">,</span> <span class="n">y_str</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span>

<span class="c1"># Each element is a dictionary mapping strings to `tf.Tensor` objects.</span>
<span class="n">c</span> <span class="o">=</span> <span class="p">{</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="s2">&quot;foo&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="s2">&quot;bar&quot;</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="s2">&quot;baz&quot;</span><span class="p">}</span> <span class="p">}</span>
<span class="c1"># `map_func` takes a single argument of type `dict` with the same keys as</span>
<span class="c1"># the elements.</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span>
</pre></div>


<p>The value or values returned by <code>map_func</code> determine the structure of each
element in the returned dataset.</p>
<div class="codehilite"><pre><span></span><span class="c1"># `map_func` returns a scalar `tf.Tensor` of type `tf.float32`.</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">37.0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_classes</span> <span class="o">==</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_types</span> <span class="o">==</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_shapes</span> <span class="o">==</span> <span class="p">[]</span>  <span class="c1"># scalar</span>

<span class="c1"># `map_func` returns two `tf.Tensor` objects.</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">(</span><span class="mf">37.0</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">constant</span><span class="p">([</span><span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="s2">&quot;Bar&quot;</span><span class="p">,</span> <span class="s2">&quot;Baz&quot;</span><span class="p">])</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_classes</span> <span class="o">==</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_types</span> <span class="o">==</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_shapes</span> <span class="o">==</span> <span class="p">([],</span> <span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># Python primitives, lists, and NumPy arrays are implicitly converted to</span>
<span class="c1"># `tf.Tensor`.</span>
<span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
  <span class="k">return</span> <span class="mf">37.0</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;Foo&quot;</span><span class="p">,</span> <span class="s2">&quot;Bar&quot;</span><span class="p">,</span> <span class="s2">&quot;Baz&quot;</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_classes</span> <span class="o">==</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_types</span> <span class="o">==</span> <span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_shapes</span> <span class="o">==</span> <span class="p">([],</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">])</span>

<span class="c1"># `map_func` can return nested structures.</span>
<span class="k">def</span> <span class="nf">i</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="mf">37.0</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">42</span><span class="p">,</span> <span class="mi">16</span><span class="p">]},</span> <span class="s2">&quot;foo&quot;</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_classes</span> <span class="o">==</span> <span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">},</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_types</span> <span class="o">==</span> <span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">int32</span><span class="p">},</span> <span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">)</span>
<span class="n">result</span><span class="o">.</span><span class="n">output_shapes</span> <span class="o">==</span> <span class="p">({</span><span class="s2">&quot;a&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">]},</span> <span class="p">[])</span>
</pre></div>


<p><code>map_func</code> can accept as arguments and return any type of dataset element.</p>
<p>Note that irrespective of the context in which <code>map_func</code> is defined (eager
vs. graph), tf.data traces the function and executes it as a graph. To use
Python code inside of the function you have two options:</p>
<p>1) Rely on AutoGraph to convert Python code into an equivalent graph
computation. The downside of this approach is that AutoGraph can convert
some but not all Python code.</p>
<p>2) Use <a href="../../../../tf/py_function.html"><code>tf.py_function</code></a>, which allows you to write arbitrary Python code but
will generally result in worse performance than 1). For example:</p>
<div class="codehilite"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="o">.</span><span class="n">from_tensor_slices</span><span class="p">([</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">])</span>

<span class="c1"># transform a string tensor to upper case string using a Python function</span>
<span class="k">def</span> <span class="nf">upper_case_fn</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">numpy</span><span class="p">()</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

<span class="n">d</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">tf</span><span class="o">.</span><span class="n">py_function</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="n">upper_case_fn</span><span class="p">,</span>
      <span class="n">inp</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">Tout</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">string</span><span class="p">))</span>  <span class="c1"># ==&gt; [ &quot;HELLO&quot;, &quot;WORLD&quot; ]</span>
</pre></div>


<h4 id="args_16">Args:</h4>
<ul>
<li><b><code>map_func</code></b>: A function mapping a dataset element to another dataset element.</li>
<li><b><code>num_parallel_calls</code></b>: (Optional.) A <a href="../../../../tf.html#int32"><code>tf.int32</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>,
  representing the number elements to process asynchronously in parallel.
  If not specified, elements will be processed sequentially. If the value
  <a href="../../../../tf/data/experimental.html#AUTOTUNE"><code>tf.data.experimental.AUTOTUNE</code></a> is used, then the number of parallel
  calls is set dynamically based on available CPU.</li>
</ul>
<h4 id="returns_21">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="map_with_legacy_function"><code>map_with_legacy_function</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">map_with_legacy_function</span><span class="p">(</span>
    <span class="n">map_func</span><span class="p">,</span>
    <span class="n">num_parallel_calls</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Maps <code>map_func</code> across the elements of this dataset. (deprecated)</p>
<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use `tf.data.Dataset.map()</p>
<p>NOTE: This is an escape hatch for existing uses of <code>map</code> that do not work
with V2 functions. New uses are strongly discouraged and existing uses
should migrate to <code>map</code> as this method will be removed in V2.</p>
<h4 id="args_17">Args:</h4>
<ul>
<li><b><code>map_func</code></b>: A function mapping a nested structure of tensors (having shapes
  and types defined by <code>self.output_shapes</code> and <code>self.output_types</code>) to
  another nested structure of tensors.</li>
<li><b><code>num_parallel_calls</code></b>: (Optional.) A <a href="../../../../tf.html#int32"><code>tf.int32</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>,
  representing the number elements to process asynchronously in parallel.
  If not specified, elements will be processed sequentially. If the value
  <a href="../../../../tf/data/experimental.html#AUTOTUNE"><code>tf.data.experimental.AUTOTUNE</code></a> is used, then the number of parallel
  calls is set dynamically based on available CPU.</li>
</ul>
<h4 id="returns_22">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="options"><code>options</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">options</span><span class="p">()</span>
</pre></div>


<p>Returns the options for this dataset and its inputs.</p>
<h4 id="returns_23">Returns:</h4>
<p>A <a href="../../../../tf/data/Options.html"><code>tf.data.Options</code></a> object representing the dataset options.</p>
<h3 id="padded_batch"><code>padded_batch</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">padded_batch</span><span class="p">(</span>
    <span class="n">batch_size</span><span class="p">,</span>
    <span class="n">padded_shapes</span><span class="p">,</span>
    <span class="n">padding_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>


<p>Combines consecutive elements of this dataset into padded batches.</p>
<p>This transformation combines multiple consecutive elements of the input
dataset into a single element.</p>
<p>Like <a href="../../../../tf/data/Dataset.html#batch"><code>tf.data.Dataset.batch</code></a>, the components of the resulting element will
have an additional outer dimension, which will be <code>batch_size</code> (or
<code>N % batch_size</code> for the last element if <code>batch_size</code> does not divide the
number of input elements <code>N</code> evenly and <code>drop_remainder</code> is <code>False</code>). If
your program depends on the batches having the same outer dimension, you
should set the <code>drop_remainder</code> argument to <code>True</code> to prevent the smaller
batch from being produced.</p>
<p>Unlike <a href="../../../../tf/data/Dataset.html#batch"><code>tf.data.Dataset.batch</code></a>, the input elements to be batched may have
different shapes, and this transformation will pad each component to the
respective shape in <code>padding_shapes</code>. The <code>padding_shapes</code> argument
determines the resulting shape for each dimension of each component in an
output element:</p>
<ul>
<li>If the dimension is a constant (e.g. <a href="../../../../tf/compat/v1/Dimension.html"><code>tf.compat.v1.Dimension(37)</code></a>), the
component
  will be padded out to that length in that dimension.</li>
<li>If the dimension is unknown (e.g. <a href="../../../../tf/compat/v1/Dimension.html"><code>tf.compat.v1.Dimension(None)</code></a>), the
component
  will be padded out to the maximum length of all elements in that
  dimension.</li>
</ul>
<p>See also <a href="../../../../tf/data/experimental/dense_to_sparse_batch.html"><code>tf.data.experimental.dense_to_sparse_batch</code></a>, which combines
elements that may have different shapes into a <a href="../../../../tf/sparse/SparseTensor.html"><code>tf.SparseTensor</code></a>.</p>
<h4 id="args_18">Args:</h4>
<ul>
<li><b><code>batch_size</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of
  consecutive elements of this dataset to combine in a single batch.</li>
<li><b><code>padded_shapes</code></b>: A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> or <a href="../../../../tf.html#int64"><code>tf.int64</code></a> vector
  tensor-like objects representing the shape to which the respective
  component of each input element should be padded prior to batching. Any
  unknown dimensions (e.g. <a href="../../../../tf/compat/v1/Dimension.html"><code>tf.compat.v1.Dimension(None)</code></a> in a
  <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> or <code>-1</code> in a tensor-like object) will be padded to the
  maximum size of that dimension in each batch.</li>
<li><b><code>padding_values</code></b>: (Optional.) A nested structure of scalar-shaped
  <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the padding values to use for the respective
  components.  Defaults are <code>0</code> for numeric types and the empty string for
  string types.</li>
<li><b><code>drop_remainder</code></b>: (Optional.) A <a href="../../../../tf.html#bool"><code>tf.bool</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing
  whether the last batch should be dropped in the case it has fewer than
  <code>batch_size</code> elements; the default behavior is not to drop the smaller
  batch.</li>
</ul>
<h4 id="returns_24">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="prefetch"><code>prefetch</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">prefetch</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> that prefetches elements from this dataset.</p>
<p>Note: Like other <code>Dataset</code> methods, prefetch operates on the
elements of the input dataset. It has no concept of examples vs. batches.
<code>examples.prefetch(2)</code> will prefetch two elements (2 examples),
while <code>examples.batch(20).prefetch(2)</code> will prefetch 2 elements
(2 batches, of 20 examples each).</p>
<h4 id="args_19">Args:</h4>
<ul>
<li><b><code>buffer_size</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the maximum
  number of elements that will be buffered when prefetching.</li>
</ul>
<h4 id="returns_25">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="range"><code>range</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> of a step-separated range of values.</p>
<h4 id="for-example_5">For example:</h4>
<div class="codehilite"><pre><span></span><span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">[]</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</pre></div>


<h4 id="args_20">Args:</h4>
<ul>
<li><b><code>*args</code></b>: follows the same semantics as python's xrange.
  len(args) == 1 -&gt; start = 0, stop = args[0], step = 1
  len(args) == 2 -&gt; start = args[0], stop = args[1], step = 1
  len(args) == 3 -&gt; start = args[0], stop = args[1, stop = args[2]</li>
</ul>
<h4 id="returns_26">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>RangeDataset</code>.</li>
</ul>
<h4 id="raises_2">Raises:</h4>
<ul>
<li><b><code>ValueError</code></b>: if len(args) == 0.</li>
</ul>
<h3 id="reduce"><code>reduce</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">reduce</span><span class="p">(</span>
    <span class="n">initial_state</span><span class="p">,</span>
    <span class="n">reduce_func</span>
<span class="p">)</span>
</pre></div>


<p>Reduces the input dataset to a single element.</p>
<p>The transformation calls <code>reduce_func</code> successively on every element of
the input dataset until the dataset is exhausted, aggregating information in
its internal state. The <code>initial_state</code> argument is used for the initial
state and the final state is returned as the result.</p>
<h4 id="for-example_6">For example:</h4>
<ul>
<li><code>tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, _: x + 1)</code>
  produces <code>5</code></li>
<li><code>tf.data.Dataset.range(5).reduce(np.int64(0), lambda x, y: x + y)</code>
  produces <code>10</code></li>
</ul>
<h4 id="args_21">Args:</h4>
<ul>
<li><b><code>initial_state</code></b>: An element representing the initial state of the
  transformation.</li>
<li><b><code>reduce_func</code></b>: A function that maps <code>(old_state, input_element)</code> to
  <code>new_state</code>. It must take two arguments and return a new element
  The structure of <code>new_state</code> must match the structure of
  <code>initial_state</code>.</li>
</ul>
<h4 id="returns_27">Returns:</h4>
<p>A dataset element corresponding to the final state of the transformation.</p>
<h3 id="repeat"><code>repeat</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">repeat</span><span class="p">(</span><span class="n">count</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>


<p>Repeats this dataset <code>count</code> times.</p>
<p>NOTE: If this dataset is a function of global state (e.g. a random number
generator), then different repetitions may produce different elements.</p>
<h4 id="args_22">Args:</h4>
<ul>
<li><b><code>count</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the
  number of times the dataset should be repeated. The default behavior (if
  <code>count</code> is <code>None</code> or <code>-1</code>) is for the dataset be repeated indefinitely.</li>
</ul>
<h4 id="returns_28">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="shard"><code>shard</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">shard</span><span class="p">(</span>
    <span class="n">num_shards</span><span class="p">,</span>
    <span class="n">index</span>
<span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> that includes only 1/<code>num_shards</code> of this dataset.</p>
<p>This dataset operator is very useful when running distributed training, as
it allows each worker to read a unique subset.</p>
<p>When reading a single input file, you can skip elements as follows:</p>
<div class="codehilite"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">TFRecordDataset</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shard</span><span class="p">(</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">worker_index</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_buffer_size</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">parser_fn</span><span class="p">,</span> <span class="n">num_parallel_calls</span><span class="o">=</span><span class="n">num_map_threads</span><span class="p">)</span>
</pre></div>


<h4 id="important-caveats">Important caveats:</h4>
<ul>
<li>Be sure to shard before you use any randomizing operator (such as
  shuffle).</li>
<li>Generally it is best if the shard operator is used early in the dataset
  pipeline. For example, when reading from a set of TFRecord files, shard
  before converting the dataset to input samples. This avoids reading every
  file on every worker. The following is an example of an efficient
  sharding strategy within a complete pipeline:</li>
</ul>
<div class="codehilite"><pre><span></span><span class="n">d</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">list_files</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shard</span><span class="p">(</span><span class="n">num_workers</span><span class="p">,</span> <span class="n">worker_index</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_buffer_size</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">TFRecordDataset</span><span class="p">,</span>
                 <span class="n">cycle_length</span><span class="o">=</span><span class="n">num_readers</span><span class="p">,</span> <span class="n">block_length</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">parser_fn</span><span class="p">,</span> <span class="n">num_parallel_calls</span><span class="o">=</span><span class="n">num_map_threads</span><span class="p">)</span>
</pre></div>


<h4 id="args_23">Args:</h4>
<ul>
<li><b><code>num_shards</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of
  shards operating in parallel.</li>
<li><b><code>index</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the worker index.</li>
</ul>
<h4 id="returns_29">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h4 id="raises_3">Raises:</h4>
<ul>
<li><b><code>InvalidArgumentError</code></b>: if <code>num_shards</code> or <code>index</code> are illegal values.
  Note: error checking is done on a best-effort basis, and errors aren't
  guaranteed to be caught upon dataset creation. (e.g. providing in a
  placeholder tensor bypasses the early checking, and will instead result
  in an error during a session.run call.)</li>
</ul>
<h3 id="shuffle"><code>shuffle</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">shuffle</span><span class="p">(</span>
    <span class="n">buffer_size</span><span class="p">,</span>
    <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">reshuffle_each_iteration</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Randomly shuffles the elements of this dataset.</p>
<p>This dataset fills a buffer with <code>buffer_size</code> elements, then randomly
samples elements from this buffer, replacing the selected elements with new
elements. For perfect shuffling, a buffer size greater than or equal to the
full size of the dataset is required.</p>
<p>For instance, if your dataset contains 10,000 elements but <code>buffer_size</code> is
set to 1,000, then <code>shuffle</code> will initially select a random element from
only the first 1,000 elements in the buffer. Once an element is selected,
its space in the buffer is replaced by the next (i.e. 1,001-st) element,
maintaining the 1,000 element buffer.</p>
<h4 id="args_24">Args:</h4>
<ul>
<li><b><code>buffer_size</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of
  elements from this dataset from which the new dataset will sample.</li>
<li><b><code>seed</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the random
  seed that will be used to create the distribution. See
  <a href="../../../../tf/compat/v1/set_random_seed.html"><code>tf.compat.v1.set_random_seed</code></a> for behavior.</li>
<li><b><code>reshuffle_each_iteration</code></b>: (Optional.) A boolean, which if true indicates
  that the dataset should be pseudorandomly reshuffled each time it is
  iterated over. (Defaults to <code>True</code>.)</li>
</ul>
<h4 id="returns_30">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="skip"><code>skip</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">skip</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> that skips <code>count</code> elements from this dataset.</p>
<h4 id="args_25">Args:</h4>
<ul>
<li><b><code>count</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of
  elements of this dataset that should be skipped to form the new dataset.
  If <code>count</code> is greater than the size of this dataset, the new dataset
  will contain no elements.  If <code>count</code> is -1, skips the entire dataset.</li>
</ul>
<h4 id="returns_31">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="take"><code>take</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">take</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> with at most <code>count</code> elements from this dataset.</p>
<h4 id="args_26">Args:</h4>
<ul>
<li><b><code>count</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of
  elements of this dataset that should be taken to form the new dataset.
  If <code>count</code> is -1, or if <code>count</code> is greater than the size of this
  dataset, the new dataset will contain all elements of this dataset.</li>
</ul>
<h4 id="returns_32">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
<h3 id="unbatch"><code>unbatch</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">unbatch</span><span class="p">()</span>
</pre></div>


<p>Splits elements of a dataset into multiple elements.</p>
<p>For example, if elements of the dataset are shaped <code>[B, a0, a1, ...]</code>,
where <code>B</code> may vary for each input element, then for each element in the
dataset, the unbatched dataset will contain <code>B</code> consecutive elements
of shape <code>[a0, a1, ...]</code>.</p>
<div class="codehilite"><pre><span></span><span class="c1"># NOTE: The following example uses `{ ... }` to represent the contents</span>
<span class="c1"># of a dataset.</span>
<span class="n">ds</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span> <span class="p">}</span>

<span class="n">ds</span><span class="o">.</span><span class="n">unbatch</span><span class="p">()</span> <span class="o">==</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>
</pre></div>


<h4 id="returns_33">Returns:</h4>
<p>A <code>Dataset</code> transformation function, which can be passed to
<a href="../../../../tf/data/Dataset.html#apply"><code>tf.data.Dataset.apply</code></a>.</p>
<h3 id="window"><code>window</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">window</span><span class="p">(</span>
    <span class="n">size</span><span class="p">,</span>
    <span class="n">shift</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">drop_remainder</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</pre></div>


<p>Combines (nests of) input elements into a dataset of (nests of) windows.</p>
<p>A "window" is a finite dataset of flat elements of size <code>size</code> (or possibly
fewer if there are not enough input elements to fill the window and
<code>drop_remainder</code> evaluates to false).</p>
<p>The <code>stride</code> argument determines the stride of the input elements, and the
<code>shift</code> argument determines the shift of the window.</p>
<p>For example, letting {...} to represent a Dataset:</p>
<ul>
<li><code>tf.data.Dataset.range(7).window(2)</code> produces
  <code>{{0, 1}, {2, 3}, {4, 5}, {6}}</code></li>
<li><code>tf.data.Dataset.range(7).window(3, 2, 1, True)</code> produces
  <code>{{0, 1, 2}, {2, 3, 4}, {4, 5, 6}}</code></li>
<li><code>tf.data.Dataset.range(7).window(3, 1, 2, True)</code> produces
  <code>{{0, 2, 4}, {1, 3, 5}, {2, 4, 6}}</code></li>
</ul>
<p>Note that when the <code>window</code> transformation is applied to a dataset of
nested elements, it produces a dataset of nested windows.</p>
<h4 id="for-example_7">For example:</h4>
<ul>
<li><code>tf.data.Dataset.from_tensor_slices((range(4), range(4))).window(2)</code>
  produces <code>{({0, 1}, {0, 1}), ({2, 3}, {2, 3})}</code></li>
<li><code>tf.data.Dataset.from_tensor_slices({"a": range(4)}).window(2)</code>
  produces <code>{{"a": {0, 1}}, {"a": {2, 3}}}</code></li>
</ul>
<h4 id="args_27">Args:</h4>
<ul>
<li><b><code>size</code></b>: A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the number of elements
  of the input dataset to combine into a window.</li>
<li><b><code>shift</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the
  forward shift of the sliding window in each iteration. Defaults to
  <code>size</code>.</li>
<li><b><code>stride</code></b>: (Optional.) A <a href="../../../../tf.html#int64"><code>tf.int64</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing the
  stride of the input elements in the sliding window.</li>
<li><b><code>drop_remainder</code></b>: (Optional.) A <a href="../../../../tf.html#bool"><code>tf.bool</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>, representing
  whether a window should be dropped in case its size is smaller than
  <code>window_size</code>.</li>
</ul>
<h4 id="returns_34">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code> of (nests of) windows -- a finite datasets of flat
  elements created from the (nests of) input elements.</li>
</ul>
<h3 id="with_options"><code>with_options</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">with_options</span><span class="p">(</span><span class="n">options</span><span class="p">)</span>
</pre></div>


<p>Returns a new <a href="../../../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> with the given options set.</p>
<p>The options are "global" in the sense they apply to the entire dataset.
If options are set multiple times, they are merged as long as different
options do not use different non-default values.</p>
<h4 id="args_28">Args:</h4>
<ul>
<li><b><code>options</code></b>: A <a href="../../../../tf/data/Options.html"><code>tf.data.Options</code></a> that identifies the options the use.</li>
</ul>
<h4 id="returns_35">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code> with the given options.</li>
</ul>
<h4 id="raises_4">Raises:</h4>
<ul>
<li><b><code>ValueError</code></b>: when an option is set more than once to a non-default value</li>
</ul>
<h3 id="zip"><code>zip</code></h3>

<p><a target="_blank" href="https://github.com/tensorflow/tensorflow/blob/r2.0/tensorflow/python/data/ops/dataset_ops.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="nb">zip</span><span class="p">(</span><span class="n">datasets</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>Dataset</code> by zipping together the given datasets.</p>
<p>This method has similar semantics to the built-in <code>zip()</code> function
in Python, with the main difference being that the <code>datasets</code>
argument can be an arbitrary nested structure of <code>Dataset</code> objects.
For example:</p>
<div class="codehilite"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 1, 2, 3 ]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 4, 5, 6 ]</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># ==&gt; [ [7, 8], [9, 10], [11, 12] ]</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">Dataset</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>  <span class="c1"># ==&gt; [ 13, 14 ]</span>

<span class="c1"># The nested structure of the `datasets` argument determines the</span>
<span class="c1"># structure of elements in the resulting dataset.</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">zip</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>  <span class="c1"># ==&gt; [ (1, 4), (2, 5), (3, 6) ]</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">zip</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span>  <span class="c1"># ==&gt; [ (4, 1), (5, 2), (6, 3) ]</span>

<span class="c1"># The `datasets` argument may contain an arbitrary number of</span>
<span class="c1"># datasets.</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">zip</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>  <span class="c1"># ==&gt; [ (1, 4, [7, 8]),</span>
                        <span class="c1">#       (2, 5, [9, 10]),</span>
                        <span class="c1">#       (3, 6, [11, 12]) ]</span>

<span class="c1"># The number of elements in the resulting dataset is the same as</span>
<span class="c1"># the size of the smallest dataset in `datasets`.</span>
<span class="n">Dataset</span><span class="o">.</span><span class="n">zip</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>  <span class="c1"># ==&gt; [ (1, 13), (2, 14) ]</span>
</pre></div>


<h4 id="args_29">Args:</h4>
<ul>
<li><b><code>datasets</code></b>: A nested structure of datasets.</li>
</ul>
<h4 id="returns_36">Returns:</h4>
<ul>
<li><b><code>Dataset</code></b>: A <code>Dataset</code>.</li>
</ul>
    </body>
    </html>
   