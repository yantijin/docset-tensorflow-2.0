
    <html lang="zh-cn">
    <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <link href=../../../default.css" rel="stylesheet">
    <link href="
   ../../../github.css" rel="stylesheet">
    </head>
    <body>
    <div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.distribute.OneDeviceStrategy" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="extended"/>
<meta itemprop="property" content="num_replicas_in_sync"/>
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="experimental_distribute_dataset"/>
<meta itemprop="property" content="experimental_distribute_datasets_from_function"/>
<meta itemprop="property" content="experimental_local_results"/>
<meta itemprop="property" content="experimental_make_numpy_dataset"/>
<meta itemprop="property" content="experimental_run_v2"/>
<meta itemprop="property" content="reduce"/>
<meta itemprop="property" content="scope"/>
</div>

<h1 id="tfdistributeonedevicestrategy">tf.distribute.OneDeviceStrategy</h1>
<!-- Insert buttons -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<h2 id="class-onedevicestrategy">Class <code>OneDeviceStrategy</code></h2>
<!-- Start diff -->

<p>A distribution strategy for running on a single device.</p>
<p>Inherits From: <a href="../../tf/distribute/Strategy.html"><code>Strategy</code></a></p>
<h3 id="aliases">Aliases:</h3>
<ul>
<li>Class <code>tf.compat.v2.distribute.OneDeviceStrategy</code></li>
</ul>
<!-- Placeholder for "Used in" -->

<p>Using this strategy will place any variables created in its scope on the
specified device. Input distributed through this strategy will be
prefetched to the specified device. Moreover, any functions called via
<code>strategy.experimental_run_v2</code> will also be placed on the specified device
as well.</p>
<p>Typical usage of this strategy could be testing your code with the
tf.distribute.Strategy API before switching to other strategies which
actually distribute to multiple devices/machines.</p>
<h4 id="for-example">For example:</h4>
<div class="codehilite"><pre><span></span><span class="n">strategy</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">distribute</span><span class="p">.</span><span class="n">OneDeviceStrategy</span><span class="p">(</span><span class="n">device</span><span class="o">=</span><span class="ss">&quot;/gpu:0&quot;</span><span class="p">)</span>

<span class="k">with</span> <span class="n">strategy</span><span class="p">.</span><span class="k">scope</span><span class="p">():</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="k">Variable</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">)</span>
  <span class="n">print</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">device</span><span class="p">)</span>  <span class="o">#</span> <span class="o">/</span><span class="n">job</span><span class="p">:</span><span class="n">localhost</span><span class="o">/</span><span class="n">replica</span><span class="p">:</span><span class="mi">0</span><span class="o">/</span><span class="n">task</span><span class="p">:</span><span class="mi">0</span><span class="o">/</span><span class="n">device</span><span class="p">:</span><span class="n">GPU</span><span class="p">:</span><span class="mi">0</span>

<span class="n">def</span> <span class="n">step_fn</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>

<span class="k">result</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
  <span class="k">result</span> <span class="o">+=</span> <span class="n">strategy</span><span class="p">.</span><span class="n">experimental_run_v2</span><span class="p">(</span><span class="n">step_fn</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,))</span>
<span class="n">print</span><span class="p">(</span><span class="k">result</span><span class="p">)</span>  <span class="o">#</span> <span class="mi">90</span>
</pre></div>


<h2 id="__init__"><code>__init__</code></h2>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="fm">__init__</span><span class="p">(</span><span class="n">device</span><span class="p">)</span>
</pre></div>


<p>Creates a <code>OneDeviceStrategy</code>.</p>
<h4 id="args">Args:</h4>
<ul>
<li><b><code>device</code></b>: Device string identifier for the device on which the variables
  should be placed. See class docs for more details on how the device is
  used. Examples: "/cpu:0", "/gpu:0", "/device:CPU:0", "/device:GPU:0"</li>
</ul>
<h2 id="properties">Properties</h2>
<h3 id="extended"><code>extended</code></h3>

<p><a href="../../tf/distribute/StrategyExtended.html"><code>tf.distribute.StrategyExtended</code></a> with additional methods.</p>
<h3 id="num_replicas_in_sync"><code>num_replicas_in_sync</code></h3>

<p>Returns number of replicas over which gradients are aggregated.</p>
<h2 id="methods">Methods</h2>
<h3 id="experimental_distribute_dataset"><code>experimental_distribute_dataset</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">experimental_distribute_dataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">)</span>
</pre></div>


<p>Distributes a tf.data.Dataset instance provided via dataset.</p>
<p>In this case, there is only one device, so this is only a thin wrapper
around the input dataset. It will, however, prefetch the input data to the
specified device. The returned distributed dataset can be iterated over
similar to how regular datasets can.</p>
<p>NOTE: Currently, the user cannot add any more transformations to a
distributed dataset.</p>
<h4 id="example">Example:</h4>
<div class="codehilite"><pre><span></span><span class="err">strategy = tf.distribute.OneDeviceStrategy()</span>
<span class="err">dataset = tf.data.Dataset.range(10).batch(2)</span>
<span class="err">dist_dataset = strategy.experimental_distribute_dataset(dataset)</span>
<span class="err">for x in dist_dataset:</span>
<span class="err">  print(x)  # [0, 1], [2, 3],...</span>
</pre></div>


<p>Args:
  dataset: <a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> to be prefetched to device.</p>
<h4 id="returns">Returns:</h4>
<p>A "distributed <code>Dataset</code>" that the caller can iterate over.</p>
<h3 id="experimental_distribute_datasets_from_function"><code>experimental_distribute_datasets_from_function</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">experimental_distribute_datasets_from_function</span><span class="p">(</span><span class="n">dataset_fn</span><span class="p">)</span>
</pre></div>


<p>Distributes <a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> instances created by calls to <code>dataset_fn</code>.</p>
<p><code>dataset_fn</code> will be called once for each worker in the strategy. In this
case, we only have one worker and one device so <code>dataset_fn</code> is called
once.</p>
<p>The <code>dataset_fn</code> should take an <a href="../../tf/distribute/InputContext.html"><code>tf.distribute.InputContext</code></a> instance where
information about batching and input replication can be accessed:</p>
<div class="codehilite"><pre><span></span><span class="n">def</span> <span class="n">dataset_fn</span><span class="p">(</span><span class="n">input_context</span><span class="p">):</span>
  <span class="n">batch_size</span> <span class="o">=</span> <span class="n">input_context</span><span class="p">.</span><span class="n">get_per_replica_batch_size</span><span class="p">(</span><span class="n">global_batch_size</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="k">data</span><span class="p">.</span><span class="n">Dataset</span><span class="p">.</span><span class="n">from_tensors</span><span class="p">([[</span><span class="mi">1</span><span class="p">.]]).</span><span class="n">repeat</span><span class="p">().</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">d</span><span class="p">.</span><span class="n">shard</span><span class="p">(</span>
      <span class="n">input_context</span><span class="p">.</span><span class="n">num_input_pipelines</span><span class="p">,</span> <span class="n">input_context</span><span class="p">.</span><span class="n">input_pipeline_id</span><span class="p">)</span>

<span class="n">inputs</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">.</span><span class="n">experimental_distribute_datasets_from_function</span><span class="p">(</span><span class="n">dataset_fn</span><span class="p">)</span>

<span class="k">for</span> <span class="n">batch</span> <span class="k">in</span> <span class="n">inputs</span><span class="p">:</span>
  <span class="n">replica_results</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">.</span><span class="n">experimental_run_v2</span><span class="p">(</span><span class="n">replica_fn</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">batch</span><span class="p">,))</span>
</pre></div>


<p>IMPORTANT: The <a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> returned by <code>dataset_fn</code> should have a
per-replica batch size, unlike <code>experimental_distribute_dataset</code>, which uses
the global batch size.  This may be computed using
<code>input_context.get_per_replica_batch_size</code>.</p>
<h4 id="args_1">Args:</h4>
<ul>
<li><b><code>dataset_fn</code></b>: A function taking a <a href="../../tf/distribute/InputContext.html"><code>tf.distribute.InputContext</code></a> instance and
  returning a <a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a>.</li>
</ul>
<h4 id="returns_1">Returns:</h4>
<p>A "distributed <code>Dataset</code>", which the caller can iterate over like regular
datasets.</p>
<h3 id="experimental_local_results"><code>experimental_local_results</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">experimental_local_results</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>


<p>Returns the list of all local per-replica values contained in <code>value</code>.</p>
<p>In <code>OneDeviceStrategy</code>, the <code>value</code> is always expected to be a single
value, so the result is just the value in a tuple.</p>
<h4 id="args_2">Args:</h4>
<ul>
<li><b><code>value</code></b>: A value returned by <code>experimental_run()</code>, <code>experimental_run_v2()</code>,
  <code>extended.call_for_each_replica()</code>, or a variable created in <code>scope</code>.</li>
</ul>
<h4 id="returns_2">Returns:</h4>
<p>A tuple of values contained in <code>value</code>. If <code>value</code> represents a single
value, this returns <code>(value,).</code></p>
<h3 id="experimental_make_numpy_dataset"><code>experimental_make_numpy_dataset</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/distribute_lib.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">experimental_make_numpy_dataset</span><span class="p">(</span><span class="n">numpy_input</span><span class="p">)</span>
</pre></div>


<p>Makes a <a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> for input provided via a numpy array.</p>
<p>This avoids adding <code>numpy_input</code> as a large constant in the graph,
and copies the data to the machine or machines that will be processing
the input.</p>
<p>Note that you will likely need to use <code>experimental_distribute_dataset</code>
with the returned dataset to further distribute it with the strategy.</p>
<h4 id="example_1">Example:</h4>
<div class="codehilite"><pre><span></span><span class="err">numpy_input = np.ones([10], dtype=np.float32)</span>
<span class="err">dataset = strategy.experimental_make_numpy_dataset(numpy_input)</span>
<span class="err">dist_dataset = strategy.experimental_distribute_dataset(dataset)</span>
</pre></div>


<h4 id="args_3">Args:</h4>
<ul>
<li><b><code>numpy_input</code></b>: A nest of NumPy input arrays that will be converted into a
dataset. Note that lists of Numpy arrays are stacked, as that is normal
<a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> behavior.</li>
</ul>
<h4 id="returns_3">Returns:</h4>
<p>A <a href="../../tf/data/Dataset.html"><code>tf.data.Dataset</code></a> representing <code>numpy_input</code>.</p>
<h3 id="experimental_run_v2"><code>experimental_run_v2</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">experimental_run_v2</span><span class="p">(</span>
    <span class="n">fn</span><span class="p">,</span>
    <span class="n">args</span><span class="o">=</span><span class="p">(),</span>
    <span class="n">kwargs</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<p>Run <code>fn</code> on each replica, with the given arguments.</p>
<p>In <code>OneDeviceStrategy</code>, <code>fn</code> is simply called within a device scope for the
given device, with the provided arguments.</p>
<h4 id="args_4">Args:</h4>
<ul>
<li><b><code>fn</code></b>: The function to run. The output must be a <a href="../../tf/nest.html"><code>tf.nest</code></a> of <code>Tensor</code>s.</li>
<li><b><code>args</code></b>: (Optional) Positional arguments to <code>fn</code>.</li>
<li><b><code>kwargs</code></b>: (Optional) Keyword arguments to <code>fn</code>.</li>
</ul>
<h4 id="returns_4">Returns:</h4>
<p>Return value from running <code>fn</code>.</p>
<h3 id="reduce"><code>reduce</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">reduce</span><span class="p">(</span>
    <span class="n">reduce_op</span><span class="p">,</span>
    <span class="n">value</span><span class="p">,</span>
    <span class="n">axis</span>
<span class="p">)</span>
</pre></div>


<p>Reduce <code>value</code> across replicas.</p>
<p>In <code>OneDeviceStrategy</code>, there is only one replica, so if axis=None, value
is simply returned. If axis is specified as something other than None,
such as axis=0, value is reduced along that axis and returned.</p>
<h4 id="example_2">Example:</h4>
<div class="codehilite"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>

<span class="k">result</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">distribute</span><span class="p">.</span><span class="n">ReduceOp</span><span class="p">.</span><span class="k">SUM</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="k">None</span><span class="p">).</span><span class="n">numpy</span><span class="p">()</span>
<span class="o">#</span> <span class="k">result</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>

<span class="k">result</span> <span class="o">=</span> <span class="n">strategy</span><span class="p">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">tf</span><span class="p">.</span><span class="n">distribute</span><span class="p">.</span><span class="n">ReduceOp</span><span class="p">.</span><span class="k">SUM</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">).</span><span class="n">numpy</span><span class="p">()</span>
<span class="o">#</span> <span class="k">result</span><span class="p">:</span> <span class="mi">45</span>
</pre></div>


<h4 id="args_5">Args:</h4>
<ul>
<li><b><code>reduce_op</code></b>: A <a href="../../tf/distribute/ReduceOp.html"><code>tf.distribute.ReduceOp</code></a> value specifying how values should
  be combined.</li>
<li><b><code>value</code></b>: A "per replica" value, e.g. returned by <code>experimental_run_v2</code> to
  be combined into a single tensor.</li>
<li><b><code>axis</code></b>: Specifies the dimension to reduce along within each
  replica's tensor. Should typically be set to the batch dimension, or
  <code>None</code> to only reduce across replicas (e.g. if the tensor has no batch
  dimension).</li>
</ul>
<h4 id="returns_5">Returns:</h4>
<p>A <code>Tensor</code>.</p>
<h3 id="scope"><code>scope</code></h3>

<p><a target="_blank" href="/code/stable/tensorflow/python/distribute/one_device_strategy.py">View source</a></p>
<div class="codehilite"><pre><span></span><span class="n">scope</span><span class="p">()</span>
</pre></div>


<p>Returns a context manager selecting this Strategy as current.</p>
<p>Inside a <code>with strategy.scope():</code> code block, this thread
will use a variable creator set by <code>strategy</code>, and will
enter its "cross-replica context".</p>
<p>In <code>OneDeviceStrategy</code>, all variables created inside <code>strategy.scope()</code>
will be on <code>device</code> specified at strategy construction time.
See example in the docs for this class.</p>
<h4 id="returns_6">Returns:</h4>
<p>A context manager to use for creating variables with this strategy.</p>
    </body>
    </html>
   