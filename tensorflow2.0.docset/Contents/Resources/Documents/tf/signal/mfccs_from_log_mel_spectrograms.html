<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.signal.mfccs_from_log_mel_spectrograms" />
<meta itemprop="path" content="Stable" />
</div>


<h1>tf.signal.mfccs_from_log_mel_spectrograms</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/signal/mfcc_ops.py">View source</a></p>

<!-- Start diff -->


<p>Computes <a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">MFCCs</a> of <code>log_mel_spectrograms</code>.</p>

<h3>Aliases:</h3>

<ul>
<li><code>tf.compat.v1.signal.mfccs_from_log_mel_spectrograms</code></li>
<li><code>tf.compat.v2.signal.mfccs_from_log_mel_spectrograms</code></li>
</ul>


<p><code>python
tf.signal.mfccs_from_log_mel_spectrograms(
    log_mel_spectrograms,
    name=None
)
</code></p>

<!-- Placeholder for "Used in" -->


<p>Implemented with GPU-compatible ops and supports gradients.</p>

<p><a href="https://en.wikipedia.org/wiki/Mel-frequency_cepstrum">Mel-Frequency Cepstral Coefficient (MFCC)</a> calculation consists of
taking the DCT-II of a log-magnitude mel-scale spectrogram. <a href="https://en.wikipedia.org/wiki/HTK_(software)">HTK</a>&rsquo;s MFCCs
use a particular scaling of the DCT-II which is almost orthogonal
normalization. We follow this convention.</p>

<p>All <code>num_mel_bins</code> MFCCs are returned and it is up to the caller to select
a subset of the MFCCs based on their application. For example, it is typical
to only use the first few for speech recognition, as this results in
an approximately pitch-invariant representation of the signal.</p>

<h4>For example:</h4>

<p>```python
sample_rate = 16000.0</p>

<h1>A Tensor of [batch_size, num_samples] mono PCM samples in the range [-1, 1].</h1>

<p>pcm = tf.compat.v1.placeholder(tf.float32, [None, None])</p>

<h1>A 1024-point STFT with frames of 64 ms and 75% overlap.</h1>

<p>stfts = tf.signal.stft(pcm, frame_length=1024, frame_step=256,
                       fft_length=1024)
spectrograms = tf.abs(stfts)</p>

<h1>Warp the linear scale spectrograms into the mel-scale.</h1>

<p>num_spectrogram_bins = stfts.shape[-1].value
lower_edge_hertz, upper_edge_hertz, num_mel_bins = 80.0, 7600.0, 80
linear_to_mel_weight_matrix = tf.signal.linear_to_mel_weight_matrix(
  num_mel_bins, num_spectrogram_bins, sample_rate, lower_edge_hertz,
  upper_edge_hertz)
mel_spectrograms = tf.tensordot(
  spectrograms, linear_to_mel_weight_matrix, 1)
mel_spectrograms.set_shape(spectrograms.shape[:-1].concatenate(
  linear_to_mel_weight_matrix.shape[-1:]))</p>

<h1>Compute a stabilized log to get log-magnitude mel-scale spectrograms.</h1>

<p>log_mel_spectrograms = tf.math.log(mel_spectrograms + 1e-6)</p>

<h1>Compute MFCCs from log_mel_spectrograms and take the first 13.</h1>

<p>mfccs = tf.signal.mfccs_from_log_mel_spectrograms(
  log_mel_spectrograms)[&hellip;, :13]
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>log_mel_spectrograms</code></b>: A <code>[..., num_mel_bins]</code> <code>float32</code> <code>Tensor</code> of
log-magnitude mel-scale spectrograms.</li>
<li><b><code>name</code></b>: An optional name for the operation.</li>
</ul>


<h4>Returns:</h4>

<p>A <code>[..., num_mel_bins]</code> <code>float32</code> <code>Tensor</code> of the MFCCs of
<code>log_mel_spectrograms</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: If <code>num_mel_bins</code> is not positive.</li>
</ul>

