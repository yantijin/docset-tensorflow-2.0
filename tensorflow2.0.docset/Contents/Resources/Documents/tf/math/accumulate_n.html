<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.math.accumulate_n" />
<meta itemprop="path" content="Stable" />
</div>


<h1>tf.math.accumulate_n</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/math_ops.py">View source</a></p>

<!-- Start diff -->


<p>Returns the element-wise sum of a list of tensors.</p>

<h3>Aliases:</h3>

<ul>
<li><code>tf.compat.v1.accumulate_n</code></li>
<li><code>tf.compat.v1.math.accumulate_n</code></li>
<li><code>tf.compat.v2.math.accumulate_n</code></li>
</ul>


<p><code>python
tf.math.accumulate_n(
    inputs,
    shape=None,
    tensor_dtype=None,
    name=None
)
</code></p>

<!-- Placeholder for "Used in" -->


<p>Optionally, pass <code>shape</code> and <code>tensor_dtype</code> for shape and type checking,
otherwise, these are inferred.</p>

<p><code>accumulate_n</code> performs the same operation as <a href="../../tf/math/add_n.html"><code>tf.math.add_n</code></a>, but
does not wait for all of its inputs to be ready before beginning to sum.
This approach can save memory if inputs are ready at different times, since
minimum temporary storage is proportional to the output size rather than the
inputs' size.</p>

<p><code>accumulate_n</code> is differentiable (but wasn&rsquo;t previous to TensorFlow 1.7).</p>

<h4>For example:</h4>

<p>```python
a = tf.constant([[1, 2], [3, 4]])
b = tf.constant([[5, 0], [0, 6]])
tf.math.accumulate_n([a, b, a])  # [[7, 4], [6, 14]]</p>

<h1>Explicitly pass shape and type</h1>

<p>tf.math.accumulate_n([a, b, a], shape=[2, 2], tensor_dtype=tf.int32)
                                                               # [[7,  4],
                                                               #  [6, 14]]
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>inputs</code></b>: A list of <code>Tensor</code> objects, each with same shape and type.</li>
<li><b><code>shape</code></b>: Expected shape of elements of <code>inputs</code> (optional). Also controls the
output shape of this op, which may affect type inference in other ops. A
value of <code>None</code> means &ldquo;infer the input shape from the shapes in <code>inputs</code>&rdquo;.</li>
<li><b><code>tensor_dtype</code></b>: Expected data type of <code>inputs</code> (optional). A value of <code>None</code>
means &ldquo;infer the input dtype from <code>inputs[0]</code>&rdquo;.</li>
<li><b><code>name</code></b>: A name for the operation (optional).</li>
</ul>


<h4>Returns:</h4>

<p>A <code>Tensor</code> of same shape and type as the elements of <code>inputs</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: If <code>inputs</code> don&rsquo;t all have same shape and dtype or the shape
cannot be inferred.</li>
</ul>

