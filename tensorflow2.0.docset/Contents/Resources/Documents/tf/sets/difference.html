<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.sets.difference" />
<meta itemprop="path" content="Stable" />
</div>


<h1>tf.sets.difference</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/sets_impl.py">View source</a></p>

<!-- Start diff -->


<p>Compute set difference of elements in last dimension of <code>a</code> and <code>b</code>.</p>

<h3>Aliases:</h3>

<ul>
<li><code>tf.compat.v1.sets.difference</code></li>
<li><code>tf.compat.v1.sets.set_difference</code></li>
<li><code>tf.compat.v2.sets.difference</code></li>
</ul>


<p><code>python
tf.sets.difference(
    a,
    b,
    aminusb=True,
    validate_indices=True
)
</code></p>

<!-- Placeholder for "Used in" -->


<p>All but the last dimension of <code>a</code> and <code>b</code> must match.</p>

<h4>Example:</h4>

<p>```python
  import tensorflow as tf
  import collections</p>

<p>  # Represent the following array of sets as a sparse tensor:
  # a = np.array([[{1, 2}, {3}], [{4}, {5, 6}]])
  a = collections.OrderedDict([
      ((0, 0, 0), 1),
      ((0, 0, 1), 2),
      ((0, 1, 0), 3),
      ((1, 0, 0), 4),
      ((1, 1, 0), 5),
      ((1, 1, 1), 6),
  ])
  a = tf.SparseTensor(list(a.keys()), list(a.values()), dense_shape=[2, 2, 2])</p>

<p>  # np.array([[{1, 3}, {2}], [{4, 5}, {5, 6, 7, 8}]])
  b = collections.OrderedDict([
      ((0, 0, 0), 1),
      ((0, 0, 1), 3),
      ((0, 1, 0), 2),
      ((1, 0, 0), 4),
      ((1, 0, 1), 5),
      ((1, 1, 0), 5),
      ((1, 1, 1), 6),
      ((1, 1, 2), 7),
      ((1, 1, 3), 8),
  ])
  b = tf.SparseTensor(list(b.keys()), list(b.values()), dense_shape=[2, 2, 4])</p>

<p>  # <code>set_difference</code> is applied to each aligned pair of sets.
  tf.sets.difference(a, b)</p>

<p>  # The result will be equivalent to either of:
  #
  # np.array([[{2}, {3}], [{}, {}]])
  #
  # collections.OrderedDict([
  #     ((0, 0, 0), 2),
  #     ((0, 1, 0), 3),
  # ])
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>a</code></b>: <code>Tensor</code> or <code>SparseTensor</code> of the same type as <code>b</code>. If sparse, indices
  must be sorted in row-major order.</li>
<li><b><code>b</code></b>: <code>Tensor</code> or <code>SparseTensor</code> of the same type as <code>a</code>. If sparse, indices
  must be sorted in row-major order.</li>
<li><b><code>aminusb</code></b>: Whether to subtract <code>b</code> from <code>a</code>, vs vice versa.</li>
<li><b><code>validate_indices</code></b>: Whether to validate the order and range of sparse indices
 in <code>a</code> and <code>b</code>.</li>
</ul>


<h4>Returns:</h4>

<p>A <code>SparseTensor</code> whose shape is the same rank as <code>a</code> and <code>b</code>, and all but
the last dimension the same. Elements along the last dimension contain the
differences.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>TypeError</code></b>: If inputs are invalid types, or if <code>a</code> and <code>b</code> have
  different types.</li>
<li><b><code>ValueError</code></b>: If <code>a</code> is sparse and <code>b</code> is dense.</li>
<li><b><code>errors_impl.InvalidArgumentError</code></b>: If the shapes of <code>a</code> and <code>b</code> do not
  match in any dimension other than the last dimension.</li>
</ul>

