<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.norm" />
<meta itemprop="path" content="Stable" />
</div>


<h1>tf.norm</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg_ops.py">View source</a></p>

<!-- Start diff -->


<p>Computes the norm of vectors, matrices, and tensors.</p>

<h3>Aliases:</h3>

<ul>
<li><code>tf.compat.v2.linalg.norm</code></li>
<li><code>tf.compat.v2.norm</code></li>
<li><code>tf.linalg.norm</code></li>
</ul>


<p><code>python
tf.norm(
    tensor,
    ord='euclidean',
    axis=None,
    keepdims=None,
    name=None
)
</code></p>

<!-- Placeholder for "Used in" -->


<p>This function can compute several different vector norms (the 1-norm, the
Euclidean or 2-norm, the inf-norm, and in general the p-norm for p > 0) and
matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).</p>

<h4>Args:</h4>

<ul>
<li><b><code>tensor</code></b>: <code>Tensor</code> of types <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code></li>
<li><b><code>ord</code></b>: Order of the norm. Supported values are <code>'fro'</code>, <code>'euclidean'</code>,
<code>1</code>, <code>2</code>, <code>np.inf</code> and any positive real number yielding the corresponding
p-norm. Default is <code>'euclidean'</code> which is equivalent to Frobenius norm if
<code>tensor</code> is a matrix and equivalent to 2-norm for vectors.
Some restrictions apply:
  a) The Frobenius norm <code>'fro'</code> is not defined for vectors,
  b) If axis is a 2-tuple (matrix norm), only <code>'euclidean'</code>, &lsquo;<code>fro'</code>, <code>1</code>,
     <code>2</code>, <code>np.inf</code> are supported.
See the description of <code>axis</code> on how to compute norms for a batch of
vectors or matrices stored in a tensor.</li>
<li><b><code>axis</code></b>: If <code>axis</code> is <code>None</code> (the default), the input is considered a vector
and a single vector norm is computed over the entire set of values in the
tensor, i.e. <code>norm(tensor, ord=ord)</code> is equivalent to
<code>norm(reshape(tensor, [-1]), ord=ord)</code>.
If <code>axis</code> is a Python integer, the input is considered a batch of vectors,
and <code>axis</code> determines the axis in <code>tensor</code> over which to compute vector
norms.
If <code>axis</code> is a 2-tuple of Python integers it is considered a batch of
matrices and <code>axis</code> determines the axes in <code>tensor</code> over which to compute
a matrix norm.
Negative indices are supported. Example: If you are passing a tensor that
can be either a matrix or a batch of matrices at runtime, pass
<code>axis=[-2,-1]</code> instead of <code>axis=None</code> to make sure that matrix norms are
computed.</li>
<li><b><code>keepdims</code></b>: If True, the axis indicated in <code>axis</code> are kept with size 1.
Otherwise, the dimensions in <code>axis</code> are removed from the output shape.</li>
<li><b><code>name</code></b>: The name of the op.</li>
</ul>


<h4>Returns:</h4>

<ul>
<li><b><code>output</code></b>: A <code>Tensor</code> of the same type as tensor, containing the vector or
matrix norms. If <code>keepdims</code> is True then the rank of output is equal to
the rank of <code>tensor</code>. Otherwise, if <code>axis</code> is none the output is a scalar,
if <code>axis</code> is an integer, the rank of <code>output</code> is one less than the rank
of <code>tensor</code>, if <code>axis</code> is a 2-tuple the rank of <code>output</code> is two less
than the rank of <code>tensor</code>.</li>
</ul>


<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: If <code>ord</code> or <code>axis</code> is invalid.</li>
</ul>


<h4>Numpy Compatibility</h4>

<p>Mostly equivalent to numpy.linalg.norm.
Not supported: ord &lt;= 0, 2-norm for matrices, nuclear norm.
Other differences:
  a) If axis is <code>None</code>, treats the flattened <code>tensor</code> as a vector
   regardless of rank.
  b) Explicitly supports &lsquo;euclidean&rsquo; norm as the default, including for
   higher order tensors.</p>
