<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.keras.optimizers.Nadam" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="iterations"/>
<meta itemprop="property" content="weights"/>
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="add_slot"/>
<meta itemprop="property" content="add_weight"/>
<meta itemprop="property" content="apply_gradients"/>
<meta itemprop="property" content="from_config"/>
<meta itemprop="property" content="get_config"/>
<meta itemprop="property" content="get_gradients"/>
<meta itemprop="property" content="get_slot"/>
<meta itemprop="property" content="get_slot_names"/>
<meta itemprop="property" content="get_updates"/>
<meta itemprop="property" content="get_weights"/>
<meta itemprop="property" content="minimize"/>
<meta itemprop="property" content="set_weights"/>
<meta itemprop="property" content="variables"/>
</div>


<h1>tf.keras.optimizers.Nadam</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/nadam.py">View source</a></p>

<h2>Class <code>Nadam</code></h2>

<!-- Start diff -->


<p>Optimizer that implements the NAdam algorithm.</p>

<p>Inherits From: <a href="../../../tf/keras/optimizers/Optimizer.html"><code>Optimizer</code></a></p>

<h3>Aliases:</h3>

<ul>
<li>Class <code>tf.compat.v1.keras.optimizers.Nadam</code></li>
<li>Class <code>tf.compat.v2.keras.optimizers.Nadam</code></li>
<li>Class <code>tf.compat.v2.optimizers.Nadam</code></li>
<li>Class <code>tf.optimizers.Nadam</code></li>
</ul>


<!-- Placeholder for "Used in" -->


<p>Much like Adam is essentially RMSprop with momentum, Nadam is Adam with
Nesterov momentum.</p>

<h4>Initialization:</h4>

<p>$$m_0 := 0 \text{(Initialize 1st moment vector)}$$
$$v_0 := 0 \text{(Initialize 2nd moment vector)}$$
$$mu_0 := 1$$
$$t := 0 \text{(Initialize timestep)}$$</p>

<h4>Computes:</h4>

<p>$$t := t + 1$$
$$\mu_t := \beta_1 * (1 - 0.5 * 0.96^{0.004 * t})$$
$$g' := g / (1 - \prod<em>{i=1}^{t}{\mu_i})$$
$$m_t := \beta_1 * m</em>{t-1} + (1 - \beta_1) * g$$
$$m' := m_t / (1 - \prod<em>{i=1}^{t+1}{\mu_i})$$
$$v_t := \beta_2 * v</em>{t-1} + (1 - \beta_2) * g * g$$
$$v' := v_t / (1 - \beta_2<sup>t</sup>)$$
$$\bar{m} := (1 - \mu_t) * g' + \mu<em>{t+1} * m'$$
$$\theta_t := \theta</em>{t-1} - lr * \bar{m} / (\sqrt{v'} + \epsilon)$$</p>

<p>gradient is evaluated at theta(t) + momentum * v(t), and the variables always
store theta + beta_1 * m / sqrt(v) instead of theta.</p>

<p>References
  See <a href="http://cs229.stanford.edu/proj2015/054_report.pdf">Dozat, T., 2015</a>.</p>

<h2 id="__init__"><code>__init__</code></h2>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/nadam.py">View source</a></p>

<p><code>python
__init__(
    learning_rate=0.001,
    beta_1=0.9,
    beta_2=0.999,
    epsilon=1e-07,
    name='Nadam',
    **kwargs
)
</code></p>

<p>Construct a new Nadam optimizer.</p>

<h4>Args:</h4>

<ul>
<li><b><code>learning_rate</code></b>: A Tensor or a floating point value.  The learning rate.</li>
<li><b><code>beta_1</code></b>: A float value or a constant float tensor. The exponential decay
rate for the 1st moment estimates.</li>
<li><b><code>beta_2</code></b>: A float value or a constant float tensor. The exponential decay
rate for the exponentially weighted infinity norm.</li>
<li><b><code>epsilon</code></b>: A small constant for numerical stability.</li>
<li><b><code>name</code></b>: Optional name for the operations created when applying gradients.
Defaults to &ldquo;Adamax&rdquo;.</li>
<li><b><code>**kwargs</code></b>: keyword arguments. Allowed to be {<code>clipnorm</code>, <code>clipvalue</code>, <code>lr</code>,
<code>decay</code>}. <code>clipnorm</code> is clip gradients by norm; <code>clipvalue</code> is clip
gradients by value, <code>decay</code> is included for backward compatibility to
allow time inverse decay of learning rate. <code>lr</code> is included for backward
compatibility, recommended to use <code>learning_rate</code> instead.</li>
</ul>


<h2>Properties</h2>

<h3 id="iterations"><code>iterations</code></h3>


<p>Variable. The number of training steps this Optimizer has run.</p>

<h3 id="weights"><code>weights</code></h3>


<p>Returns variables of this Optimizer based on the order created.</p>

<h2>Methods</h2>

<h3 id="add_slot"><code>add_slot</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
add_slot(
    var,
    slot_name,
    initializer='zeros'
)
</code></p>

<p>Add a new slot variable for <code>var</code>.</p>

<h3 id="add_weight"><code>add_weight</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
add_weight(
    name,
    shape,
    dtype=None,
    initializer='zeros',
    trainable=None,
    synchronization=tf.VariableSynchronization.AUTO,
    aggregation=tf.compat.v1.VariableAggregation.NONE
)
</code></p>

<h3 id="apply_gradients"><code>apply_gradients</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
apply_gradients(
    grads_and_vars,
    name=None
)
</code></p>

<p>Apply gradients to variables.</p>

<p>This is the second part of <code>minimize()</code>. It returns an <code>Operation</code> that
applies gradients.</p>

<h4>Args:</h4>

<ul>
<li><b><code>grads_and_vars</code></b>: List of (gradient, variable) pairs.</li>
<li><b><code>name</code></b>: Optional name for the returned operation.  Default to the name
passed to the <code>Optimizer</code> constructor.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Operation</code> that applies the specified gradients. If <code>global_step</code>
was not None, that operation also increments <code>global_step</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>TypeError</code></b>: If <code>grads_and_vars</code> is malformed.</li>
<li><b><code>ValueError</code></b>: If none of the variables have gradients.</li>
</ul>


<h3 id="from_config"><code>from_config</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
from_config(
    cls,
    config,
    custom_objects=None
)
</code></p>

<p>Creates an optimizer from its config.</p>

<p>This method is the reverse of <code>get_config</code>,
capable of instantiating the same optimizer from the config
dictionary.</p>

<h4>Arguments:</h4>

<ul>
<li><b><code>config</code></b>: A Python dictionary, typically the output of get_config.</li>
<li><b><code>custom_objects</code></b>: A Python dictionary mapping names to additional Python
objects used to create this optimizer, such as a function used for a
hyperparameter.</li>
</ul>


<h4>Returns:</h4>

<p>An optimizer instance.</p>

<h3 id="get_config"><code>get_config</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/nadam.py">View source</a></p>

<p><code>python
get_config()
</code></p>

<p>Returns the config of the optimimizer.</p>

<p>An optimizer config is a Python dictionary (serializable)
containing the configuration of an optimizer.
The same optimizer can be reinstantiated later
(without any saved state) from this configuration.</p>

<h4>Returns:</h4>

<p>Python dictionary.</p>

<h3 id="get_gradients"><code>get_gradients</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
get_gradients(
    loss,
    params
)
</code></p>

<p>Returns gradients of <code>loss</code> with respect to <code>params</code>.</p>

<h4>Arguments:</h4>

<ul>
<li><b><code>loss</code></b>: Loss tensor.</li>
<li><b><code>params</code></b>: List of variables.</li>
</ul>


<h4>Returns:</h4>

<p>List of gradient tensors.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: In case any gradient cannot be computed (e.g. if gradient
function not implemented).</li>
</ul>


<h3 id="get_slot"><code>get_slot</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
get_slot(
    var,
    slot_name
)
</code></p>

<h3 id="get_slot_names"><code>get_slot_names</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
get_slot_names()
</code></p>

<p>A list of names for this optimizer&rsquo;s slots.</p>

<h3 id="get_updates"><code>get_updates</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
get_updates(
    loss,
    params
)
</code></p>

<h3 id="get_weights"><code>get_weights</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
get_weights()
</code></p>

<h3 id="minimize"><code>minimize</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
minimize(
    loss,
    var_list,
    grad_loss=None,
    name=None
)
</code></p>

<p>Minimize <code>loss</code> by updating <code>var_list</code>.</p>

<p>This method simply computes gradient using <a href="../../../tf/GradientTape.html"><code>tf.GradientTape</code></a> and calls
<code>apply_gradients()</code>. If you want to process the gradient before applying
then call <a href="../../../tf/GradientTape.html"><code>tf.GradientTape</code></a> and <code>apply_gradients()</code> explicitly instead
of using this function.</p>

<h4>Args:</h4>

<ul>
<li><b><code>loss</code></b>: A callable taking no arguments which returns the value to minimize.</li>
<li><b><code>var_list</code></b>: list or tuple of <code>Variable</code> objects to update to minimize
<code>loss</code>, or a callable returning the list or tuple of <code>Variable</code> objects.
Use callable when the variable list would otherwise be incomplete before
<code>minimize</code> since the variables are created at the first time <code>loss</code> is
called.</li>
<li><b><code>grad_loss</code></b>: Optional. A <code>Tensor</code> holding the gradient computed for <code>loss</code>.</li>
<li><b><code>name</code></b>: Optional name for the returned operation.</li>
</ul>


<h4>Returns:</h4>

<p>An Operation that updates the variables in <code>var_list</code>.  If <code>global_step</code>
was not <code>None</code>, that operation also increments <code>global_step</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: If some of the variables are not <code>Variable</code> objects.</li>
</ul>


<h3 id="set_weights"><code>set_weights</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
set_weights(weights)
</code></p>

<h3 id="variables"><code>variables</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/keras/optimizer_v2/optimizer_v2.py">View source</a></p>

<p><code>python
variables()
</code></p>

<p>Returns variables of this Optimizer based on the order created.</p>
