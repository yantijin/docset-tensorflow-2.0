<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.CriticalSection" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="name"/>
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="execute"/>
</div>


<h1>tf.CriticalSection</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/critical_section_ops.py">View source</a></p>

<h2>Class <code>CriticalSection</code></h2>

<!-- Start diff -->


<p>Critical section.</p>

<h3>Aliases:</h3>

<ul>
<li>Class <code>tf.compat.v1.CriticalSection</code></li>
<li>Class <code>tf.compat.v2.CriticalSection</code></li>
</ul>


<!-- Placeholder for "Used in" -->


<p>A <code>CriticalSection</code> object is a resource in the graph which executes subgraphs
in <strong>serial</strong> order.  A common example of a subgraph one may wish to run
exclusively is the one given by the following function:</p>

<p>```python
v = resource_variable_ops.ResourceVariable(0.0, name=&ldquo;v&rdquo;)</p>

<p>def count():
  value = v.read_value()
  with tf.control_dependencies([value]):
    with tf.control_dependencies([v.assign_add(1)]):
      return tf.identity(value)
```</p>

<p>Here, a snapshot of <code>v</code> is captured in <code>value</code>; and then <code>v</code> is updated.
The snapshot value is returned.</p>

<p>If multiple workers or threads all execute <code>count</code> in parallel, there is no
guarantee that access to the variable <code>v</code> is atomic at any point within
any thread&rsquo;s calculation of <code>count</code>.  In fact, even implementing an atomic
counter that guarantees that the user will see each value <code>0, 1, ...,</code> is
currently impossible.</p>

<p>The solution is to ensure any access to the underlying resource <code>v</code> is
only processed through a critical section:</p>

<p><code>python
cs = CriticalSection()
f1 = cs.execute(count)
f2 = cs.execute(count)
output = f1 + f2
session.run(output)
</code>
The functions <code>f1</code> and <code>f2</code> will be executed serially, and updates to <code>v</code>
will be atomic.</p>

<p><strong>NOTES</strong></p>

<p>All resource objects, including the critical section and any captured
variables of functions executed on that critical section, will be
colocated to the same device (host and cpu/gpu).</p>

<p>When using multiple critical sections on the same resources, there is no
guarantee of exclusive access to those resources.  This behavior is disallowed
by default (but see the kwarg <code>exclusive_resource_access</code>).</p>

<p>For example, running the same function in two separate critical sections
will not ensure serial execution:</p>

<p><code>python
v = tf.compat.v1.get_variable("v", initializer=0.0, use_resource=True)
def accumulate(up):
  x = v.read_value()
  with tf.control_dependencies([x]):
    with tf.control_dependencies([v.assign_add(up)]):
      return tf.identity(x)
ex1 = CriticalSection().execute(
  accumulate, 1.0, exclusive_resource_access=False)
ex2 = CriticalSection().execute(
  accumulate, 1.0, exclusive_resource_access=False)
bad_sum = ex1 + ex2
sess.run(v.initializer)
sess.run(bad_sum)  # May return 0.0
</code></p>

<h2 id="__init__"><code>__init__</code></h2>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/critical_section_ops.py">View source</a></p>

<p><code>python
__init__(
    name=None,
    shared_name=None,
    critical_section_def=None,
    import_scope=None
)
</code></p>

<p>Creates a critical section.</p>

<h2>Properties</h2>

<h3 id="name"><code>name</code></h3>


<h2>Methods</h2>

<h3 id="execute"><code>execute</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/critical_section_ops.py">View source</a></p>

<p><code>python
execute(
    fn,
    exclusive_resource_access=True,
    name=None
)
</code></p>

<p>Execute function <code>fn()</code> inside the critical section.</p>

<p><code>fn</code> should not accept any arguments.  To add extra arguments to when
calling <code>fn</code> in the critical section, create a lambda:</p>

<p><code>python
critical_section.execute(lambda: fn(*my_args, **my_kwargs))
</code></p>

<h4>Args:</h4>

<ul>
<li><b><code>fn</code></b>: The function to execute.  Must return at least one tensor.</li>
<li><b><code>exclusive_resource_access</code></b>: Whether the resources required by
<code>fn</code> should be exclusive to this <code>CriticalSection</code>.  Default: <code>True</code>.
You may want to set this to <code>False</code> if you will be accessing a
resource in read-only mode in two different CriticalSections.</li>
<li><b><code>name</code></b>: The name to use when creating the execute operation.</li>
</ul>


<h4>Returns:</h4>

<p>The tensors returned from <code>fn()</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: If <code>fn</code> attempts to lock this <code>CriticalSection</code> in any nested
or lazy way that may cause a deadlock.</li>
<li><b><code>ValueError</code></b>: If <code>exclusive_resource_access == True</code> and
another <code>CriticalSection</code> has an execution requesting the same
resources as <code>fn``.  Note, even if</code>exclusive_resource_access<code>is
</code>True<code>, if another execution in another</code>CriticalSection<code>was created
without</code>exclusive_resource_access=True<code>, a</code>ValueError` will be raised.</li>
</ul>

