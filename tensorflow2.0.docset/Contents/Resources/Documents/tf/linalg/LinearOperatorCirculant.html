<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.linalg.LinearOperatorCirculant" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="H"/>
<meta itemprop="property" content="batch_shape"/>
<meta itemprop="property" content="block_depth"/>
<meta itemprop="property" content="block_shape"/>
<meta itemprop="property" content="domain_dimension"/>
<meta itemprop="property" content="dtype"/>
<meta itemprop="property" content="graph_parents"/>
<meta itemprop="property" content="is_non_singular"/>
<meta itemprop="property" content="is_positive_definite"/>
<meta itemprop="property" content="is_self_adjoint"/>
<meta itemprop="property" content="is_square"/>
<meta itemprop="property" content="range_dimension"/>
<meta itemprop="property" content="shape"/>
<meta itemprop="property" content="spectrum"/>
<meta itemprop="property" content="tensor_rank"/>
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="add_to_tensor"/>
<meta itemprop="property" content="adjoint"/>
<meta itemprop="property" content="assert_hermitian_spectrum"/>
<meta itemprop="property" content="assert_non_singular"/>
<meta itemprop="property" content="assert_positive_definite"/>
<meta itemprop="property" content="assert_self_adjoint"/>
<meta itemprop="property" content="batch_shape_tensor"/>
<meta itemprop="property" content="block_shape_tensor"/>
<meta itemprop="property" content="cholesky"/>
<meta itemprop="property" content="convolution_kernel"/>
<meta itemprop="property" content="determinant"/>
<meta itemprop="property" content="diag_part"/>
<meta itemprop="property" content="domain_dimension_tensor"/>
<meta itemprop="property" content="inverse"/>
<meta itemprop="property" content="log_abs_determinant"/>
<meta itemprop="property" content="matmul"/>
<meta itemprop="property" content="matvec"/>
<meta itemprop="property" content="range_dimension_tensor"/>
<meta itemprop="property" content="shape_tensor"/>
<meta itemprop="property" content="solve"/>
<meta itemprop="property" content="solvevec"/>
<meta itemprop="property" content="tensor_rank_tensor"/>
<meta itemprop="property" content="to_dense"/>
<meta itemprop="property" content="trace"/>
</div>


<h1>tf.linalg.LinearOperatorCirculant</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator_circulant.py">View source</a></p>

<h2>Class <code>LinearOperatorCirculant</code></h2>

<!-- Start diff -->


<p><code>LinearOperator</code> acting like a circulant matrix.</p>

<h3>Aliases:</h3>

<ul>
<li>Class <code>tf.compat.v1.linalg.LinearOperatorCirculant</code></li>
<li>Class <code>tf.compat.v2.linalg.LinearOperatorCirculant</code></li>
</ul>


<!-- Placeholder for "Used in" -->


<p>This operator acts like a circulant matrix <code>A</code> with
shape <code>[B1,...,Bb, N, N]</code> for some <code>b &gt;= 0</code>.  The first <code>b</code> indices index a
batch member.  For every batch index <code>(i1,...,ib)</code>, <code>A[i1,...,ib, : :]</code> is
an <code>N x N</code> matrix.  This matrix <code>A</code> is not materialized, but for
purposes of broadcasting this shape will be relevant.</p>

<h4>Description in terms of circulant matrices</h4>

<p>Circulant means the entries of <code>A</code> are generated by a single vector, the
convolution kernel <code>h</code>: <code>A_{mn} := h_{m-n mod N}</code>.  With <code>h = [w, x, y, z]</code>,</p>

<p><code>
A = |w z y x|
    |x w z y|
    |y x w z|
    |z y x w|
</code></p>

<p>This means that the result of matrix multiplication <code>v = Au</code> has <code>Lth</code> column
given circular convolution between <code>h</code> with the <code>Lth</code> column of <code>u</code>.</p>

<p>See http://ee.stanford.edu/~gray/toeplitz.pdf</p>

<h4>Description in terms of the frequency spectrum</h4>

<p>There is an equivalent description in terms of the [batch] spectrum <code>H</code> and
Fourier transforms.  Here we consider <code>A.shape = [N, N]</code> and ignore batch
dimensions.  Define the discrete Fourier transform (DFT) and its inverse by</p>

<p><code>
DFT[ h[n] ] = H[k] := sum_{n = 0}^{N - 1} h_n e^{-i 2pi k n / N}
IDFT[ H[k] ] = h[n] = N^{-1} sum_{k = 0}^{N - 1} H_k e^{i 2pi k n / N}
</code></p>

<p>From these definitions, we see that</p>

<p><code>
H[0] = sum_{n = 0}^{N - 1} h_n
H[1] = "the first positive frequency"
H[N - 1] = "the first negative frequency"
</code></p>

<p>Loosely speaking, with <code>*</code> element-wise multiplication, matrix multiplication
is equal to the action of a Fourier multiplier: <code>A u = IDFT[ H * DFT[u] ]</code>.
Precisely speaking, given <code>[N, R]</code> matrix <code>u</code>, let <code>DFT[u]</code> be the <code>[N, R]</code>
matrix with <code>rth</code> column equal to the DFT of the <code>rth</code> column of <code>u</code>.
Define the <code>IDFT</code> similarly.
Matrix multiplication may be expressed columnwise:</p>

<p><code>(A u)_r = IDFT[ H * (DFT[u])_r ]</code></p>

<h4>Operator properties deduced from the spectrum.</h4>

<p>Letting <code>U</code> be the <code>kth</code> Euclidean basis vector, and <code>U = IDFT[u]</code>.
The above formulas show that<code>A U = H_k * U</code>.  We conclude that the elements
of <code>H</code> are the eigenvalues of this operator.   Therefore</p>

<ul>
<li>This operator is positive definite if and only if <code>Real{H} &gt; 0</code>.</li>
</ul>


<p>A general property of Fourier transforms is the correspondence between
Hermitian functions and real valued transforms.</p>

<p>Suppose <code>H.shape = [B1,...,Bb, N]</code>.  We say that <code>H</code> is a Hermitian spectrum
if, with <code>%</code> meaning modulus division,</p>

<p><code>H[..., n % N] = ComplexConjugate[ H[..., (-n) % N] ]</code></p>

<ul>
<li>This operator corresponds to a real matrix if and only if <code>H</code> is Hermitian.</li>
<li>This operator is self-adjoint if and only if <code>H</code> is real.</li>
</ul>


<p>See e.g. &ldquo;Discrete-Time Signal Processing&rdquo;, Oppenheim and Schafer.</p>

<h4>Example of a self-adjoint positive definite operator</h4>

<p>```python</p>

<h1>spectrum is real ==> operator is self-adjoint</h1>

<h1>spectrum is positive ==> operator is positive definite</h1>

<p>spectrum = [6., 4, 2]</p>

<p>operator = LinearOperatorCirculant(spectrum)</p>

<h1>IFFT[spectrum]</h1>

<p>operator.convolution_kernel()
==> [4 + 0j, 1 + 0.58j, 1 - 0.58j]</p>

<p>operator.to_dense()
==> [[4 + 0.0j, 1 - 0.6j, 1 + 0.6j],
     [1 + 0.6j, 4 + 0.0j, 1 - 0.6j],
     [1 - 0.6j, 1 + 0.6j, 4 + 0.0j]]
```</p>

<h4>Example of defining in terms of a real convolution kernel</h4>

<p>```python</p>

<h1>convolution_kernel is real ==> spectrum is Hermitian.</h1>

<p>convolution_kernel = [1., 2., 1.]]
spectrum = tf.signal.fft(tf.cast(convolution_kernel, tf.complex64))</p>

<h1>spectrum is Hermitian ==> operator is real.</h1>

<h1>spectrum is shape [3] ==> operator is shape [3, 3]</h1>

<h1>We force the input/output type to be real, which allows this to operate</h1>

<h1>like a real matrix.</h1>

<p>operator = LinearOperatorCirculant(spectrum, input_output_dtype=tf.float32)</p>

<p>operator.to_dense()
==> [[ 1, 1, 2],
     [ 2, 1, 1],
     [ 1, 2, 1]]
```</p>

<h4>Example of Hermitian spectrum</h4>

<p>```python</p>

<h1>spectrum is shape [3] ==> operator is shape [3, 3]</h1>

<h1>spectrum is Hermitian ==> operator is real.</h1>

<p>spectrum = [1, 1j, -1j]</p>

<p>operator = LinearOperatorCirculant(spectrum)</p>

<p>operator.to_dense()
==> [[ 0.33 + 0j,  0.91 + 0j, -0.24 + 0j],
     [-0.24 + 0j,  0.33 + 0j,  0.91 + 0j],
     [ 0.91 + 0j, -0.24 + 0j,  0.33 + 0j]
```</p>

<h4>Example of forcing real <code>dtype</code> when spectrum is Hermitian</h4>

<p>```python</p>

<h1>spectrum is shape [4] ==> operator is shape [4, 4]</h1>

<h1>spectrum is real ==> operator is self-adjoint</h1>

<h1>spectrum is Hermitian ==> operator is real</h1>

<h1>spectrum has positive real part ==> operator is positive-definite.</h1>

<p>spectrum = [6., 4, 2, 4]</p>

<h1>Force the input dtype to be float32.</h1>

<h1>Cast the output to float32.  This is fine because the operator will be</h1>

<h1>real due to Hermitian spectrum.</h1>

<p>operator = LinearOperatorCirculant(spectrum, input_output_dtype=tf.float32)</p>

<p>operator.shape
==> [4, 4]</p>

<p>operator.to_dense()
==> [[4, 1, 0, 1],
     [1, 4, 1, 0],
     [0, 1, 4, 1],
     [1, 0, 1, 4]]</p>

<h1>convolution_kernel = tf.signal.ifft(spectrum)</h1>

<p>operator.convolution_kernel()
==> [4, 1, 0, 1]
```</p>

<h4>Performance</h4>

<p>Suppose <code>operator</code> is a <code>LinearOperatorCirculant</code> of shape <code>[N, N]</code>,
and <code>x.shape = [N, R]</code>.  Then</p>

<ul>
<li><code>operator.matmul(x)</code> is <code>O(R*N*Log[N])</code></li>
<li><code>operator.solve(x)</code> is <code>O(R*N*Log[N])</code></li>
<li><code>operator.determinant()</code> involves a size <code>N</code> <code>reduce_prod</code>.</li>
</ul>


<p>If instead <code>operator</code> and <code>x</code> have shape <code>[B1,...,Bb, N, N]</code> and
<code>[B1,...,Bb, N, R]</code>, every operation increases in complexity by <code>B1*...*Bb</code>.</p>

<h4>Matrix property hints</h4>

<p>This <code>LinearOperator</code> is initialized with boolean flags of the form <code>is_X</code>,
for <code>X = non_singular, self_adjoint, positive_definite, square</code>.
These have the following meaning:</p>

<ul>
<li>If <code>is_X == True</code>, callers should expect the operator to have the
property <code>X</code>.  This is a promise that should be fulfilled, but is <em>not</em> a
runtime assert.  For example, finite floating point precision may result
in these promises being violated.</li>
<li>If <code>is_X == False</code>, callers should expect the operator to not have <code>X</code>.</li>
<li>If <code>is_X == None</code> (the default), callers should have no expectation either
way.</li>
</ul>


<h2 id="__init__"><code>__init__</code></h2>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator_circulant.py">View source</a></p>

<p><code>python
__init__(
    spectrum,
    input_output_dtype=tf.dtypes.complex64,
    is_non_singular=None,
    is_self_adjoint=None,
    is_positive_definite=None,
    is_square=True,
    name='LinearOperatorCirculant'
)
</code></p>

<p>Initialize an <code>LinearOperatorCirculant</code>.</p>

<p>This <code>LinearOperator</code> is initialized to have shape <code>[B1,...,Bb, N, N]</code>
by providing <code>spectrum</code>, a <code>[B1,...,Bb, N]</code> <code>Tensor</code>.</p>

<p>If <code>input_output_dtype = DTYPE</code>:</p>

<ul>
<li>Arguments to methods such as <code>matmul</code> or <code>solve</code> must be <code>DTYPE</code>.</li>
<li>Values returned by all methods, such as <code>matmul</code> or <code>determinant</code> will be
cast to <code>DTYPE</code>.</li>
</ul>


<p>Note that if the spectrum is not Hermitian, then this operator corresponds
to a complex matrix with non-zero imaginary part.  In this case, setting
<code>input_output_dtype</code> to a real type will forcibly cast the output to be
real, resulting in incorrect results!</p>

<p>If on the other hand the spectrum is Hermitian, then this operator
corresponds to a real-valued matrix, and setting <code>input_output_dtype</code> to
a real type is fine.</p>

<h4>Args:</h4>

<ul>
<li><b><code>spectrum</code></b>:  Shape <code>[B1,...,Bb, N]</code> <code>Tensor</code>.  Allowed dtypes: <code>float16</code>,
<code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code>.  Type can be different
than <code>input_output_dtype</code></li>
<li><b><code>input_output_dtype</code></b>: <code>dtype</code> for input/output.</li>
<li><b><code>is_non_singular</code></b>:  Expect that this operator is non-singular.</li>
<li><b><code>is_self_adjoint</code></b>:  Expect that this operator is equal to its hermitian
transpose.  If <code>spectrum</code> is real, this will always be true.</li>
<li><b><code>is_positive_definite</code></b>:  Expect that this operator is positive definite,
meaning the quadratic form <code>x^H A x</code> has positive real part for all
nonzero <code>x</code>.  Note that we do not require the operator to be
self-adjoint to be positive-definite.  See:
https://en.wikipedia.org/wiki/Positive-definite_matrix\
    #Extension_for_non_symmetric_matrices</li>
<li><b><code>is_square</code></b>:  Expect that this operator acts like square [batch] matrices.</li>
<li><b><code>name</code></b>:  A name to prepend to all ops created by this class.</li>
</ul>


<h2>Properties</h2>

<h3 id="H"><code>H</code></h3>


<p>Returns the adjoint of the current <code>LinearOperator</code>.</p>

<p>Given <code>A</code> representing this <code>LinearOperator</code>, return <code>A*</code>.
Note that calling <code>self.adjoint()</code> and <code>self.H</code> are equivalent.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>LinearOperator</code> which represents the adjoint of this <code>LinearOperator</code>.</p>

<h3 id="batch_shape"><code>batch_shape</code></h3>


<p><code>TensorShape</code> of batch dimensions of this <code>LinearOperator</code>.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns
<code>TensorShape([B1,...,Bb])</code>, equivalent to <code>A.get_shape()[:-2]</code></p>

<h4>Returns:</h4>

<p><code>TensorShape</code>, statically determined, may be undefined.</p>

<h3 id="block_depth"><code>block_depth</code></h3>


<p>Depth of recursively defined circulant blocks defining this <code>Operator</code>.</p>

<p>With <code>A</code> the dense representation of this <code>Operator</code>,</p>

<p><code>block_depth = 1</code> means <code>A</code> is symmetric circulant.  For example,</p>

<p><code>
A = |w z y x|
    |x w z y|
    |y x w z|
    |z y x w|
</code></p>

<p><code>block_depth = 2</code> means <code>A</code> is block symmetric circulant with symemtric
circulant blocks.  For example, with <code>W</code>, <code>X</code>, <code>Y</code>, <code>Z</code> symmetric circulant,</p>

<p><code>
A = |W Z Y X|
    |X W Z Y|
    |Y X W Z|
    |Z Y X W|
</code></p>

<p><code>block_depth = 3</code> means <code>A</code> is block symmetric circulant with block
symmetric circulant blocks.</p>

<h4>Returns:</h4>

<p>Python <code>integer</code>.</p>

<h3 id="block_shape"><code>block_shape</code></h3>




<h3 id="domain_dimension"><code>domain_dimension</code></h3>


<p>Dimension (in the sense of vector spaces) of the domain of this operator.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>N</code>.</p>

<h4>Returns:</h4>

<p><code>Dimension</code> object.</p>

<h3 id="dtype"><code>dtype</code></h3>


<p>The <code>DType</code> of <code>Tensor</code>s handled by this <code>LinearOperator</code>.</p>

<h3 id="graph_parents"><code>graph_parents</code></h3>


<p>List of graph dependencies of this <code>LinearOperator</code>.</p>

<h3 id="is_non_singular"><code>is_non_singular</code></h3>




<h3 id="is_positive_definite"><code>is_positive_definite</code></h3>




<h3 id="is_self_adjoint"><code>is_self_adjoint</code></h3>




<h3 id="is_square"><code>is_square</code></h3>


<p>Return <code>True/False</code> depending on if this operator is square.</p>

<h3 id="range_dimension"><code>range_dimension</code></h3>


<p>Dimension (in the sense of vector spaces) of the range of this operator.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>M</code>.</p>

<h4>Returns:</h4>

<p><code>Dimension</code> object.</p>

<h3 id="shape"><code>shape</code></h3>


<p><code>TensorShape</code> of this <code>LinearOperator</code>.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns
<code>TensorShape([B1,...,Bb, M, N])</code>, equivalent to <code>A.get_shape()</code>.</p>

<h4>Returns:</h4>

<p><code>TensorShape</code>, statically determined, may be undefined.</p>

<h3 id="spectrum"><code>spectrum</code></h3>




<h3 id="tensor_rank"><code>tensor_rank</code></h3>


<p>Rank (in the sense of tensors) of matrix corresponding to this operator.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>b + 2</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>Python integer, or None if the tensor rank is undefined.</p>

<h2>Methods</h2>

<h3 id="add_to_tensor"><code>add_to_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
add_to_tensor(
    x,
    name='add_to_tensor'
)
</code></p>

<p>Add matrix represented by this operator to <code>x</code>.  Equivalent to <code>A + x</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>x</code></b>:  <code>Tensor</code> with same <code>dtype</code> and shape broadcastable to <code>self.shape</code>.</li>
<li><b><code>name</code></b>:  A name to give this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>A <code>Tensor</code> with broadcast shape and same <code>dtype</code> as <code>self</code>.</p>

<h3 id="adjoint"><code>adjoint</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
adjoint(name='adjoint')
</code></p>

<p>Returns the adjoint of the current <code>LinearOperator</code>.</p>

<p>Given <code>A</code> representing this <code>LinearOperator</code>, return <code>A*</code>.
Note that calling <code>self.adjoint()</code> and <code>self.H</code> are equivalent.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>LinearOperator</code> which represents the adjoint of this <code>LinearOperator</code>.</p>

<h3 id="assert_hermitian_spectrum"><code>assert_hermitian_spectrum</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator_circulant.py">View source</a></p>

<p><code>python
assert_hermitian_spectrum(name='assert_hermitian_spectrum')
</code></p>

<p>Returns an <code>Op</code> that asserts this operator has Hermitian spectrum.</p>

<p>This operator corresponds to a real-valued matrix if and only if its
spectrum is Hermitian.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name to give this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Op</code> that asserts this operator has Hermitian spectrum.</p>

<h3 id="assert_non_singular"><code>assert_non_singular</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
assert_non_singular(name='assert_non_singular')
</code></p>

<p>Returns an <code>Op</code> that asserts this operator is non singular.</p>

<p>This operator is considered non-singular if</p>

<p><code>
ConditionNumber &lt; max{100, range_dimension, domain_dimension} * eps,
eps := np.finfo(self.dtype.as_numpy_dtype).eps
</code></p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A string name to prepend to created ops.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Assert</code> <code>Op</code>, that, when run, will raise an <code>InvalidArgumentError</code> if
  the operator is singular.</p>

<h3 id="assert_positive_definite"><code>assert_positive_definite</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
assert_positive_definite(name='assert_positive_definite')
</code></p>

<p>Returns an <code>Op</code> that asserts this operator is positive definite.</p>

<p>Here, positive definite means that the quadratic form <code>x^H A x</code> has positive
real part for all nonzero <code>x</code>.  Note that we do not require the operator to
be self-adjoint to be positive definite.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name to give this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Assert</code> <code>Op</code>, that, when run, will raise an <code>InvalidArgumentError</code> if
  the operator is not positive definite.</p>

<h3 id="assert_self_adjoint"><code>assert_self_adjoint</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
assert_self_adjoint(name='assert_self_adjoint')
</code></p>

<p>Returns an <code>Op</code> that asserts this operator is self-adjoint.</p>

<p>Here we check that this operator is <em>exactly</em> equal to its hermitian
transpose.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A string name to prepend to created ops.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Assert</code> <code>Op</code>, that, when run, will raise an <code>InvalidArgumentError</code> if
  the operator is not self-adjoint.</p>

<h3 id="batch_shape_tensor"><code>batch_shape_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
batch_shape_tensor(name='batch_shape_tensor')
</code></p>

<p>Shape of batch dimensions of this operator, determined at runtime.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns a <code>Tensor</code> holding
<code>[B1,...,Bb]</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>int32</code> <code>Tensor</code></p>

<h3 id="block_shape_tensor"><code>block_shape_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator_circulant.py">View source</a></p>

<p><code>python
block_shape_tensor()
</code></p>

<p>Shape of the block dimensions of <code>self.spectrum</code>.</p>

<h3 id="cholesky"><code>cholesky</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
cholesky(name='cholesky')
</code></p>

<p>Returns a Cholesky factor as a <code>LinearOperator</code>.</p>

<p>Given <code>A</code> representing this <code>LinearOperator</code>, if <code>A</code> is positive definite
self-adjoint, return <code>L</code>, where <code>A = L L^T</code>, i.e. the cholesky
decomposition.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>LinearOperator</code> which represents the lower triangular matrix
in the Cholesky decomposition.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: When the <code>LinearOperator</code> is not hinted to be positive
definite and self adjoint.</li>
</ul>


<h3 id="convolution_kernel"><code>convolution_kernel</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator_circulant.py">View source</a></p>

<p><code>python
convolution_kernel(name='convolution_kernel')
</code></p>

<p>Convolution kernel corresponding to <code>self.spectrum</code>.</p>

<p>The <code>D</code> dimensional DFT of this kernel is the frequency domain spectrum of
this operator.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name to give this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>Tensor</code> with <code>dtype</code> <code>self.dtype</code>.</p>

<h3 id="determinant"><code>determinant</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
determinant(name='det')
</code></p>

<p>Determinant for every batch member.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>Tensor</code> with shape <code>self.batch_shape</code> and same <code>dtype</code> as <code>self</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>NotImplementedError</code></b>:  If <code>self.is_square</code> is <code>False</code>.</li>
</ul>


<h3 id="diag_part"><code>diag_part</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
diag_part(name='diag_part')
</code></p>

<p>Efficiently get the [batch] diagonal part of this operator.</p>

<p>If this operator has shape <code>[B1,...,Bb, M, N]</code>, this returns a
<code>Tensor</code> <code>diagonal</code>, of shape <code>[B1,...,Bb, min(M, N)]</code>, where
<code>diagonal[b1,...,bb, i] = self.to_dense()[b1,...,bb, i, i]</code>.</p>

<p>```
my_operator = LinearOperatorDiag([1., 2.])</p>

<h1>Efficiently get the diagonal</h1>

<p>my_operator.diag_part()
==> [1., 2.]</p>

<h1>Equivalent, but inefficient method</h1>

<p>tf.linalg.diag_part(my_operator.to_dense())
==> [1., 2.]
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<ul>
<li><b><code>diag_part</code></b>:  A <code>Tensor</code> of same <code>dtype</code> as self.</li>
</ul>


<h3 id="domain_dimension_tensor"><code>domain_dimension_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
domain_dimension_tensor(name='domain_dimension_tensor')
</code></p>

<p>Dimension (in the sense of vector spaces) of the domain of this operator.</p>

<p>Determined at runtime.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>N</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>int32</code> <code>Tensor</code></p>

<h3 id="inverse"><code>inverse</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
inverse(name='inverse')
</code></p>

<p>Returns the Inverse of this <code>LinearOperator</code>.</p>

<p>Given <code>A</code> representing this <code>LinearOperator</code>, return a <code>LinearOperator</code>
representing <code>A^-1</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>: A name scope to use for ops added by this method.</li>
</ul>


<h4>Returns:</h4>

<p><code>LinearOperator</code> representing inverse of this matrix.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: When the <code>LinearOperator</code> is not hinted to be <code>non_singular</code>.</li>
</ul>


<h3 id="log_abs_determinant"><code>log_abs_determinant</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
log_abs_determinant(name='log_abs_det')
</code></p>

<p>Log absolute value of determinant for every batch member.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>Tensor</code> with shape <code>self.batch_shape</code> and same <code>dtype</code> as <code>self</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>NotImplementedError</code></b>:  If <code>self.is_square</code> is <code>False</code>.</li>
</ul>


<h3 id="matmul"><code>matmul</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
matmul(
    x,
    adjoint=False,
    adjoint_arg=False,
    name='matmul'
)
</code></p>

<p>Transform [batch] matrix <code>x</code> with left multiplication:  <code>x --&gt; Ax</code>.</p>

<p>```python</p>

<h1>Make an operator acting like batch matrix A.  Assume A.shape = [&hellip;, M, N]</h1>

<p>operator = LinearOperator(&hellip;)
operator.shape = [&hellip;, M, N]</p>

<p>X = &hellip; # shape [&hellip;, N, R], batch matrix, R > 0.</p>

<p>Y = operator.matmul(X)
Y.shape
==> [&hellip;, M, R]</p>

<p>Y[&hellip;, :, r] = sum_j A[&hellip;, :, j] X[j, r]
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>x</code></b>: <code>LinearOperator</code> or <code>Tensor</code> with compatible shape and same <code>dtype</code> as
<code>self</code>. See class docstring for definition of compatibility.</li>
<li><b><code>adjoint</code></b>: Python <code>bool</code>.  If <code>True</code>, left multiply by the adjoint: <code>A^H x</code>.</li>
<li><b><code>adjoint_arg</code></b>:  Python <code>bool</code>.  If <code>True</code>, compute <code>A x^H</code> where <code>x^H</code> is
the hermitian transpose (transposition and complex conjugation).</li>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>A <code>LinearOperator</code> or <code>Tensor</code> with shape <code>[..., M, R]</code> and same <code>dtype</code>
  as <code>self</code>.</p>

<h3 id="matvec"><code>matvec</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
matvec(
    x,
    adjoint=False,
    name='matvec'
)
</code></p>

<p>Transform [batch] vector <code>x</code> with left multiplication:  <code>x --&gt; Ax</code>.</p>

<p>```python</p>

<h1>Make an operator acting like batch matric A.  Assume A.shape = [&hellip;, M, N]</h1>

<p>operator = LinearOperator(&hellip;)</p>

<p>X = &hellip; # shape [&hellip;, N], batch vector</p>

<p>Y = operator.matvec(X)
Y.shape
==> [&hellip;, M]</p>

<p>Y[&hellip;, :] = sum_j A[&hellip;, :, j] X[&hellip;, j]
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>x</code></b>: <code>Tensor</code> with compatible shape and same <code>dtype</code> as <code>self</code>.
<code>x</code> is treated as a [batch] vector meaning for every set of leading
dimensions, the last dimension defines a vector.
See class docstring for definition of compatibility.</li>
<li><b><code>adjoint</code></b>: Python <code>bool</code>.  If <code>True</code>, left multiply by the adjoint: <code>A^H x</code>.</li>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>A <code>Tensor</code> with shape <code>[..., M]</code> and same <code>dtype</code> as <code>self</code>.</p>

<h3 id="range_dimension_tensor"><code>range_dimension_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
range_dimension_tensor(name='range_dimension_tensor')
</code></p>

<p>Dimension (in the sense of vector spaces) of the range of this operator.</p>

<p>Determined at runtime.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>M</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>int32</code> <code>Tensor</code></p>

<h3 id="shape_tensor"><code>shape_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
shape_tensor(name='shape_tensor')
</code></p>

<p>Shape of this <code>LinearOperator</code>, determined at runtime.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns a <code>Tensor</code> holding
<code>[B1,...,Bb, M, N]</code>, equivalent to <a href="../../tf/shape.html"><code>tf.shape(A)</code></a>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>int32</code> <code>Tensor</code></p>

<h3 id="solve"><code>solve</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
solve(
    rhs,
    adjoint=False,
    adjoint_arg=False,
    name='solve'
)
</code></p>

<p>Solve (exact or approx) <code>R</code> (batch) systems of equations: <code>A X = rhs</code>.</p>

<p>The returned <code>Tensor</code> will be close to an exact solution if <code>A</code> is well
conditioned. Otherwise closeness will vary. See class docstring for details.</p>

<h4>Examples:</h4>

<p>```python</p>

<h1>Make an operator acting like batch matrix A.  Assume A.shape = [&hellip;, M, N]</h1>

<p>operator = LinearOperator(&hellip;)
operator.shape = [&hellip;, M, N]</p>

<h1>Solve R > 0 linear systems for every member of the batch.</h1>

<p>RHS = &hellip; # shape [&hellip;, M, R]</p>

<p>X = operator.solve(RHS)</p>

<h1>X[&hellip;, :, r] is the solution to the r'th linear system</h1>

<h1>sum_j A[&hellip;, :, j] X[&hellip;, j, r] = RHS[&hellip;, :, r]</h1>

<p>operator.matmul(X)
==> RHS
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>rhs</code></b>: <code>Tensor</code> with same <code>dtype</code> as this operator and compatible shape.
<code>rhs</code> is treated like a [batch] matrix meaning for every set of leading
dimensions, the last two dimensions defines a matrix.
See class docstring for definition of compatibility.</li>
<li><b><code>adjoint</code></b>: Python <code>bool</code>.  If <code>True</code>, solve the system involving the adjoint
of this <code>LinearOperator</code>:  <code>A^H X = rhs</code>.</li>
<li><b><code>adjoint_arg</code></b>:  Python <code>bool</code>.  If <code>True</code>, solve <code>A X = rhs^H</code> where <code>rhs^H</code>
is the hermitian transpose (transposition and complex conjugation).</li>
<li><b><code>name</code></b>:  A name scope to use for ops added by this method.</li>
</ul>


<h4>Returns:</h4>

<p><code>Tensor</code> with shape <code>[...,N, R]</code> and same <code>dtype</code> as <code>rhs</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>NotImplementedError</code></b>:  If <code>self.is_non_singular</code> or <code>is_square</code> is False.</li>
</ul>


<h3 id="solvevec"><code>solvevec</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
solvevec(
    rhs,
    adjoint=False,
    name='solve'
)
</code></p>

<p>Solve single equation with best effort: <code>A X = rhs</code>.</p>

<p>The returned <code>Tensor</code> will be close to an exact solution if <code>A</code> is well
conditioned. Otherwise closeness will vary. See class docstring for details.</p>

<h4>Examples:</h4>

<p>```python</p>

<h1>Make an operator acting like batch matrix A.  Assume A.shape = [&hellip;, M, N]</h1>

<p>operator = LinearOperator(&hellip;)
operator.shape = [&hellip;, M, N]</p>

<h1>Solve one linear system for every member of the batch.</h1>

<p>RHS = &hellip; # shape [&hellip;, M]</p>

<p>X = operator.solvevec(RHS)</p>

<h1>X is the solution to the linear system</h1>

<h1>sum_j A[&hellip;, :, j] X[&hellip;, j] = RHS[&hellip;, :]</h1>

<p>operator.matvec(X)
==> RHS
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>rhs</code></b>: <code>Tensor</code> with same <code>dtype</code> as this operator.
<code>rhs</code> is treated like a [batch] vector meaning for every set of leading
dimensions, the last dimension defines a vector.  See class docstring
for definition of compatibility regarding batch dimensions.</li>
<li><b><code>adjoint</code></b>: Python <code>bool</code>.  If <code>True</code>, solve the system involving the adjoint
of this <code>LinearOperator</code>:  <code>A^H X = rhs</code>.</li>
<li><b><code>name</code></b>:  A name scope to use for ops added by this method.</li>
</ul>


<h4>Returns:</h4>

<p><code>Tensor</code> with shape <code>[...,N]</code> and same <code>dtype</code> as <code>rhs</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>NotImplementedError</code></b>:  If <code>self.is_non_singular</code> or <code>is_square</code> is False.</li>
</ul>


<h3 id="tensor_rank_tensor"><code>tensor_rank_tensor</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
tensor_rank_tensor(name='tensor_rank_tensor')
</code></p>

<p>Rank (in the sense of tensors) of matrix corresponding to this operator.</p>

<p>If this operator acts like the batch matrix <code>A</code> with
<code>A.shape = [B1,...,Bb, M, N]</code>, then this returns <code>b + 2</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p><code>int32</code> <code>Tensor</code>, determined at runtime.</p>

<h3 id="to_dense"><code>to_dense</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
to_dense(name='to_dense')
</code></p>

<p>Return a dense (batch) matrix representing this operator.</p>

<h3 id="trace"><code>trace</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/linalg/linear_operator.py">View source</a></p>

<p><code>python
trace(name='trace')
</code></p>

<p>Trace of the linear operator, equal to sum of <code>self.diag_part()</code>.</p>

<p>If the operator is square, this is also the sum of the eigenvalues.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>:  A name for this <code>Op</code>.</li>
</ul>


<h4>Returns:</h4>

<p>Shape <code>[B1,...,Bb]</code> <code>Tensor</code> of same <code>dtype</code> as <code>self</code>.</p>
