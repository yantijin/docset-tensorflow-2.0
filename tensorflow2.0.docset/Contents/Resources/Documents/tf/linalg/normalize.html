
    <html lang="zh-cn">
    <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type" />
    <link href=../../../default.css" rel="stylesheet">
    <link href="
   ../../../github.css" rel="stylesheet">
    </head>
    <body>
    <div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.linalg.normalize" />
<meta itemprop="path" content="Stable" />
</div>

<h1 id="tflinalgnormalize">tf.linalg.normalize</h1>
<!-- Insert buttons -->

<table class="tfo-notebook-buttons tfo-api" align="left">
</table>

<p><a target="_blank" href="/code/stable/tensorflow/python/ops/nn_impl.py">View source</a></p>
<!-- Start diff -->

<p>Normalizes <code>tensor</code> along dimension <code>axis</code> using specified norm.</p>
<h3 id="aliases">Aliases:</h3>
<ul>
<li><code>tf.compat.v1.linalg.normalize</code></li>
<li><code>tf.compat.v2.linalg.normalize</code></li>
</ul>
<div class="codehilite"><pre><span></span><span class="n">tf</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span>
    <span class="n">tensor</span><span class="p">,</span>
    <span class="nb">ord</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
    <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="kc">None</span>
<span class="p">)</span>
</pre></div>


<!-- Placeholder for "Used in" -->

<p>This uses <a href="../../tf/norm.html"><code>tf.linalg.norm</code></a> to compute the norm along <code>axis</code>.</p>
<p>This function can compute several different vector norms (the 1-norm, the
Euclidean or 2-norm, the inf-norm, and in general the p-norm for p &gt; 0) and
matrix norms (Frobenius, 1-norm, 2-norm and inf-norm).</p>
<h4 id="args">Args:</h4>
<ul>
<li><b><code>tensor</code></b>: <code>Tensor</code> of types <code>float32</code>, <code>float64</code>, <code>complex64</code>, <code>complex128</code></li>
<li><b><code>ord</code></b>: Order of the norm. Supported values are <code>'fro'</code>, <code>'euclidean'</code>, <code>1</code>,
  <code>2</code>, <code>np.inf</code> and any positive real number yielding the corresponding
  p-norm. Default is <code>'euclidean'</code> which is equivalent to Frobenius norm if
  <code>tensor</code> is a matrix and equivalent to 2-norm for vectors.
  Some restrictions apply: a) The Frobenius norm <code>'fro'</code> is not defined for
    vectors, b) If axis is a 2-tuple (matrix norm), only <code>'euclidean'</code>,
    '<code>fro'</code>, <code>1</code>, <code>2</code>, <code>np.inf</code> are supported. See the description of <code>axis</code>
    on how to compute norms for a batch of vectors or matrices stored in a
    tensor.</li>
<li><b><code>axis</code></b>: If <code>axis</code> is <code>None</code> (the default), the input is considered a vector
  and a single vector norm is computed over the entire set of values in the
  tensor, i.e. <code>norm(tensor, ord=ord)</code> is equivalent to
  <code>norm(reshape(tensor, [-1]), ord=ord)</code>. If <code>axis</code> is a Python integer, the
  input is considered a batch of vectors, and <code>axis</code> determines the axis in
  <code>tensor</code> over which to compute vector norms. If <code>axis</code> is a 2-tuple of
  Python integers it is considered a batch of matrices and <code>axis</code> determines
  the axes in <code>tensor</code> over which to compute a matrix norm.
  Negative indices are supported. Example: If you are passing a tensor that
    can be either a matrix or a batch of matrices at runtime, pass
    <code>axis=[-2,-1]</code> instead of <code>axis=None</code> to make sure that matrix norms are
    computed.</li>
<li><b><code>name</code></b>: The name of the op.</li>
</ul>
<h4 id="returns">Returns:</h4>
<ul>
<li><b><code>normalized</code></b>: A normalized <code>Tensor</code> with the same shape as <code>tensor</code>.</li>
<li><b><code>norm</code></b>: The computed norms with the same shape and dtype <code>tensor</code> but the
  final axis is 1 instead. Same as running
  <code>tf.cast(tf.linalg.norm(tensor, ord, axis keepdims=True), tensor.dtype)</code>.</li>
</ul>
<h4 id="raises">Raises:</h4>
<ul>
<li><b><code>ValueError</code></b>: If <code>ord</code> or <code>axis</code> is invalid.</li>
</ul>
    </body>
    </html>
   