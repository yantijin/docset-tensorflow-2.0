<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack" />
<meta itemprop="path" content="Stable" />
</div>


<h1>tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/util/tf_stack.py">View source</a></p>

<!-- Start diff -->


<p>A lightweight, extensible re-implementation of traceback.extract_stack.</p>

<h3>Aliases:</h3>

<ul>
<li><code>tf.compat.v1.app.flags.tf_decorator.tf_stack.extract_stack</code></li>
</ul>


<p><code>python
tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack(limit=None)
</code></p>

<!-- Placeholder for "Used in" -->


<p>NOTE(mrry): traceback.extract_stack eagerly retrieves the line of code for
    each stack frame using linecache, which results in an abundance of stat()
    calls. This implementation does not retrieve the code, and any consumer
    should apply _convert_stack to the result to obtain a traceback that can
    be formatted etc. using traceback methods.</p>

<h4>Args:</h4>

<ul>
<li><b><code>limit</code></b>: A limit on the number of frames to return.</li>
</ul>


<h4>Returns:</h4>

<p>A list of 5-tuples
    (filename, lineno, name, frame_globals, func_start_lineno)
corresponding to the call stack of the current thread.  The returned tuples
have the innermost stack frame at the end, unlike the Python inspect
module&rsquo;s stack() function.</p>
