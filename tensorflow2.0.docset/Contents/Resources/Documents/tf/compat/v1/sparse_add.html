<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.compat.v1.sparse_add" />
<meta itemprop="path" content="Stable" />
</div>


<h1>tf.compat.v1.sparse_add</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/ops/sparse_ops.py">View source</a></p>

<!-- Start diff -->


<p>Adds two tensors, at least one of each is a <code>SparseTensor</code>. (deprecated arguments)</p>

<h3>Aliases:</h3>

<ul>
<li><code>tf.compat.v1.sparse.add</code></li>
</ul>


<p><code>python
tf.compat.v1.sparse_add(
    a,
    b,
    threshold=None,
    thresh=None
)
</code></p>

<!-- Placeholder for "Used in" -->


<p>Warning: SOME ARGUMENTS ARE DEPRECATED: <code>(thresh)</code>. They will be removed in a future version.
Instructions for updating:
thresh is deprecated, use threshold instead</p>

<p>If one <code>SparseTensor</code> and one <code>Tensor</code> are passed in, returns a <code>Tensor</code>.  If
both arguments are <code>SparseTensor</code>s, this returns a <code>SparseTensor</code>.  The order
of arguments does not matter.  Use vanilla <a href="../../../tf/math/add.html"><code>tf.add()</code></a> for adding two dense
<code>Tensor</code>s.</p>

<p>The shapes of the two operands must match: broadcasting is not supported.</p>

<p>The indices of any input <code>SparseTensor</code> are assumed ordered in standard
lexicographic order.  If this is not the case, before this step run
<code>SparseReorder</code> to restore index ordering.</p>

<p>If both arguments are sparse, we perform &ldquo;clipping&rdquo; as follows.  By default,
if two values sum to zero at some index, the output <code>SparseTensor</code> would still
include that particular location in its index, storing a zero in the
corresponding value slot.  To override this, callers can specify <code>thresh</code>,
indicating that if the sum has a magnitude strictly smaller than <code>thresh</code>, its
corresponding value and index would then not be included.  In particular,
<code>thresh == 0.0</code> (default) means everything is kept and actual thresholding
happens only for a positive value.</p>

<p>For example, suppose the logical sum of two sparse operands is (densified):</p>

<pre><code>[       2]
[.1     0]
[ 6   -.2]
</code></pre>

<p>Then,</p>

<ul>
<li><code>thresh == 0</code> (the default): all 5 index/value pairs will be returned.</li>
<li><code>thresh == 0.11</code>: only .1 and 0 will vanish, and the remaining three
  index/value pairs will be returned.</li>
<li><code>thresh == 0.21</code>: .1, 0, and -.2 will vanish.</li>
</ul>


<h4>Args:</h4>

<ul>
<li><b><code>a</code></b>: The first operand; <code>SparseTensor</code> or <code>Tensor</code>.</li>
<li><b><code>b</code></b>: The second operand; <code>SparseTensor</code> or <code>Tensor</code>. At least one operand
must be sparse.</li>
<li><b><code>threshold</code></b>: An optional 0-D <code>Tensor</code> (defaults to <code>0</code>). The magnitude
threshold that determines if an output value/index pair takes space. Its
dtype should match that of the values if they are real; if the latter are
complex64/complex128, then the dtype should be float32/float64,
correspondingly.</li>
<li><b><code>thresh</code></b>: Deprecated alias for <code>threshold</code>.</li>
</ul>


<h4>Returns:</h4>

<p>A <code>SparseTensor</code> or a <code>Tensor</code>, representing the sum.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>TypeError</code></b>: If both <code>a</code> and <code>b</code> are <code>Tensor</code>s.  Use <a href="../../../tf/math/add.html"><code>tf.add()</code></a> instead.</li>
</ul>

