<div itemscope itemtype="http://developers.google.com/ReferenceObject">
<meta itemprop="name" content="tf.compat.v1.data.Iterator" />
<meta itemprop="path" content="Stable" />
<meta itemprop="property" content="element_spec"/>
<meta itemprop="property" content="initializer"/>
<meta itemprop="property" content="output_classes"/>
<meta itemprop="property" content="output_shapes"/>
<meta itemprop="property" content="output_types"/>
<meta itemprop="property" content="__init__"/>
<meta itemprop="property" content="from_string_handle"/>
<meta itemprop="property" content="from_structure"/>
<meta itemprop="property" content="get_next"/>
<meta itemprop="property" content="make_initializer"/>
<meta itemprop="property" content="string_handle"/>
</div>


<h1>tf.compat.v1.data.Iterator</h1>

<!-- Insert buttons -->




<table class="tfo-notebook-buttons tfo-api" align="left">
</table>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<h2>Class <code>Iterator</code></h2>

<!-- Start diff -->


<p>Represents the state of iterating through a <code>Dataset</code>.</p>

<!-- Placeholder for "Used in" -->




<h2 id="__init__"><code>__init__</code></h2>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<p><code>python
__init__(
    iterator_resource,
    initializer,
    output_types,
    output_shapes,
    output_classes
)
</code></p>

<p>Creates a new iterator from the given iterator resource.</p>

<p>Note: Most users will not call this initializer directly, and will
instead use <code>Dataset.make_initializable_iterator()</code> or
<code>Dataset.make_one_shot_iterator()</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>iterator_resource</code></b>: A <a href="../../../../tf.html#resource"><code>tf.resource</code></a> scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> representing the
iterator.</li>
<li><b><code>initializer</code></b>: A <a href="../../../../tf/Operation.html"><code>tf.Operation</code></a> that should be run to initialize this
iterator.</li>
<li><b><code>output_types</code></b>: A nested structure of <a href="../../../../tf/dtypes/DType.html"><code>tf.DType</code></a> objects corresponding to
each component of an element of this iterator.</li>
<li><b><code>output_shapes</code></b>: A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> objects
corresponding to each component of an element of this iterator.</li>
<li><b><code>output_classes</code></b>: A nested structure of Python <code>type</code> objects corresponding
to each component of an element of this iterator.</li>
</ul>


<h2>Properties</h2>

<h3 id="element_spec"><code>element_spec</code></h3>


<p>The type specification of an element of this iterator.</p>

<h4>Returns:</h4>

<p>A nested structure of <a href="../../../../tf/TypeSpec.html"><code>tf.TypeSpec</code></a> objects matching the structure of an
element of this iterator and specifying the type of individual components.</p>

<h3 id="initializer"><code>initializer</code></h3>


<p>A <a href="../../../../tf/Operation.html"><code>tf.Operation</code></a> that should be run to initialize this iterator.</p>

<h4>Returns:</h4>

<p>A <a href="../../../../tf/Operation.html"><code>tf.Operation</code></a> that should be run to initialize this iterator</p>

<h4>Raises:</h4>

<ul>
<li><b><code>ValueError</code></b>: If this iterator initializes itself automatically.</li>
</ul>


<h3 id="output_classes"><code>output_classes</code></h3>


<p>Returns the class of each component of an element of this iterator. (deprecated)</p>

<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/compat/v1/data/get_output_classes.html"><code>tf.compat.v1.data.get_output_classes(iterator)</code></a>.</p>

<p>The expected values are <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> and <a href="../../../../tf/sparse/SparseTensor.html"><code>tf.SparseTensor</code></a>.</p>

<h4>Returns:</h4>

<p>A nested structure of Python <code>type</code> objects corresponding to each
component of an element of this dataset.</p>

<h3 id="output_shapes"><code>output_shapes</code></h3>


<p>Returns the shape of each component of an element of this iterator. (deprecated)</p>

<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/compat/v1/data/get_output_shapes.html"><code>tf.compat.v1.data.get_output_shapes(iterator)</code></a>.</p>

<h4>Returns:</h4>

<p>A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> objects corresponding to each
component of an element of this dataset.</p>

<h3 id="output_types"><code>output_types</code></h3>


<p>Returns the type of each component of an element of this iterator. (deprecated)</p>

<p>Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use <a href="../../../../tf/compat/v1/data/get_output_types.html"><code>tf.compat.v1.data.get_output_types(iterator)</code></a>.</p>

<h4>Returns:</h4>

<p>A nested structure of <a href="../../../../tf/dtypes/DType.html"><code>tf.DType</code></a> objects corresponding to each component
of an element of this dataset.</p>

<h2>Methods</h2>

<h3 id="from_string_handle"><code>from_string_handle</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<p><code>python
@staticmethod
from_string_handle(
    string_handle,
    output_types,
    output_shapes=None,
    output_classes=None
)
</code></p>

<p>Creates a new, uninitialized <code>Iterator</code> based on the given handle.</p>

<p>This method allows you to define a &ldquo;feedable&rdquo; iterator where you can choose
between concrete iterators by feeding a value in a <code>tf.Session.run</code> call.
In that case, <code>string_handle</code> would be a <a href="../../../../tf/compat/v1/placeholder.html"><code>tf.compat.v1.placeholder</code></a>, and you
would
feed it with the value of <code>tf.data.Iterator.string_handle</code> in each step.</p>

<p>For example, if you had two iterators that marked the current position in
a training dataset and a test dataset, you could choose which to use in
each step as follows:</p>

<p>```python
train_iterator = tf.data.Dataset(&hellip;).make_one_shot_iterator()
train_iterator_handle = sess.run(train_iterator.string_handle())</p>

<p>test_iterator = tf.data.Dataset(&hellip;).make_one_shot_iterator()
test_iterator_handle = sess.run(test_iterator.string_handle())</p>

<p>handle = tf.compat.v1.placeholder(tf.string, shape=[])
iterator = tf.data.Iterator.from_string_handle(
    handle, train_iterator.output_types)</p>

<p>next_element = iterator.get_next()
loss = f(next_element)</p>

<p>train_loss = sess.run(loss, feed_dict={handle: train_iterator_handle})
test_loss = sess.run(loss, feed_dict={handle: test_iterator_handle})
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>string_handle</code></b>: A scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> of type <a href="../../../../tf.html#string"><code>tf.string</code></a> that evaluates to
a handle produced by the <code>Iterator.string_handle()</code> method.</li>
<li><b><code>output_types</code></b>: A nested structure of <a href="../../../../tf/dtypes/DType.html"><code>tf.DType</code></a> objects corresponding to
each component of an element of this dataset.</li>
<li><b><code>output_shapes</code></b>: (Optional.) A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> objects
corresponding to each component of an element of this dataset. If
omitted, each component will have an unconstrainted shape.</li>
<li><b><code>output_classes</code></b>: (Optional.) A nested structure of Python <code>type</code> objects
corresponding to each component of an element of this iterator. If
omitted, each component is assumed to be of type <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Iterator</code>.</p>

<h3 id="from_structure"><code>from_structure</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<p><code>python
@staticmethod
from_structure(
    output_types,
    output_shapes=None,
    shared_name=None,
    output_classes=None
)
</code></p>

<p>Creates a new, uninitialized <code>Iterator</code> with the given structure.</p>

<p>This iterator-constructing method can be used to create an iterator that
is reusable with many different datasets.</p>

<p>The returned iterator is not bound to a particular dataset, and it has
no <code>initializer</code>. To initialize the iterator, run the operation returned by
<code>Iterator.make_initializer(dataset)</code>.</p>

<p>The following is an example</p>

<p>```python
iterator = Iterator.from_structure(tf.int64, tf.TensorShape([]))</p>

<p>dataset_range = Dataset.range(10)
range_initializer = iterator.make_initializer(dataset_range)</p>

<p>dataset_evens = dataset_range.filter(lambda x: x % 2 == 0)
evens_initializer = iterator.make_initializer(dataset_evens)</p>

<h1>Define a model based on the iterator; in this example, the model_fn</h1>

<h1>is expected to take scalar tf.int64 Tensors as input (see</h1>

<h1>the definition of &lsquo;iterator&rsquo; above).</h1>

<p>prediction, loss = model_fn(iterator.get_next())</p>

<h1>Train for <code>num_epochs</code>, where for each epoch, we first iterate over</h1>

<h1>dataset_range, and then iterate over dataset_evens.</h1>

<p>for _ in range(num_epochs):
  # Initialize the iterator to <code>dataset_range</code>
  sess.run(range_initializer)
  while True:
    try:
      pred, loss_val = sess.run([prediction, loss])
    except tf.errors.OutOfRangeError:
      break</p>

<p>  # Initialize the iterator to <code>dataset_evens</code>
  sess.run(evens_initializer)
  while True:
    try:
      pred, loss_val = sess.run([prediction, loss])
    except tf.errors.OutOfRangeError:
      break
```</p>

<h4>Args:</h4>

<ul>
<li><b><code>output_types</code></b>: A nested structure of <a href="../../../../tf/dtypes/DType.html"><code>tf.DType</code></a> objects corresponding to
each component of an element of this dataset.</li>
<li><b><code>output_shapes</code></b>: (Optional.) A nested structure of <a href="../../../../tf/TensorShape.html"><code>tf.TensorShape</code></a> objects
corresponding to each component of an element of this dataset. If
omitted, each component will have an unconstrainted shape.</li>
<li><b><code>shared_name</code></b>: (Optional.) If non-empty, this iterator will be shared under
the given name across multiple sessions that share the same devices
(e.g. when using a remote server).</li>
<li><b><code>output_classes</code></b>: (Optional.) A nested structure of Python <code>type</code> objects
corresponding to each component of an element of this iterator. If
omitted, each component is assumed to be of type <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>.</li>
</ul>


<h4>Returns:</h4>

<p>An <code>Iterator</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>TypeError</code></b>: If the structures of <code>output_shapes</code> and <code>output_types</code> are
not the same.</li>
</ul>


<h3 id="get_next"><code>get_next</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<p><code>python
get_next(name=None)
</code></p>

<p>Returns a nested structure of <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a>s representing the next element.</p>

<p>In graph mode, you should typically call this method <em>once</em> and use its
result as the input to another computation. A typical loop will then call
<code>tf.Session.run</code> on the result of that computation. The loop will terminate
when the <code>Iterator.get_next()</code> operation raises
<a href="../../../../tf/errors/OutOfRangeError.html"><code>tf.errors.OutOfRangeError</code></a>. The following skeleton shows how to use
this method when building a training loop:</p>

<p><code>``python
dataset = ...  # A</code>tf.data.Dataset` object.
iterator = dataset.make_initializable_iterator()
next_element = iterator.get_next()</p>

<h1>Build a TensorFlow graph that does something with each element.</h1>

<p>loss = model_function(next_element)
optimizer = &hellip;  # A <code>tf.compat.v1.train.Optimizer</code> object.
train_op = optimizer.minimize(loss)</p>

<p>with tf.compat.v1.Session() as sess:
  try:
    while True:
      sess.run(train_op)
  except tf.errors.OutOfRangeError:
    pass
```</p>

<p>NOTE: It is legitimate to call <code>Iterator.get_next()</code> multiple times, e.g.
when you are distributing different elements to multiple devices in a single
step. However, a common pitfall arises when users call <code>Iterator.get_next()</code>
in each iteration of their training loop. <code>Iterator.get_next()</code> adds ops to
the graph, and executing each op allocates resources (including threads); as
a consequence, invoking it in every iteration of a training loop causes
slowdown and eventual resource exhaustion. To guard against this outcome, we
log a warning when the number of uses crosses a fixed threshold of
suspiciousness.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>: (Optional.) A name for the created operation.</li>
</ul>


<h4>Returns:</h4>

<p>A nested structure of <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> objects.</p>

<h3 id="make_initializer"><code>make_initializer</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<p><code>python
make_initializer(
    dataset,
    name=None
)
</code></p>

<p>Returns a <a href="../../../../tf/Operation.html"><code>tf.Operation</code></a> that initializes this iterator on <code>dataset</code>.</p>

<h4>Args:</h4>

<ul>
<li><b><code>dataset</code></b>: A <code>Dataset</code> with compatible structure to this iterator.</li>
<li><b><code>name</code></b>: (Optional.) A name for the created operation.</li>
</ul>


<h4>Returns:</h4>

<p>A <a href="../../../../tf/Operation.html"><code>tf.Operation</code></a> that can be run to initialize this iterator on the given
<code>dataset</code>.</p>

<h4>Raises:</h4>

<ul>
<li><b><code>TypeError</code></b>: If <code>dataset</code> and this iterator do not have a compatible
element structure.</li>
</ul>


<h3 id="string_handle"><code>string_handle</code></h3>


<p><a target="_blank" href="/code/stable/tensorflow/python/data/ops/iterator_ops.py">View source</a></p>

<p><code>python
string_handle(name=None)
</code></p>

<p>Returns a string-valued <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> that represents this iterator.</p>

<h4>Args:</h4>

<ul>
<li><b><code>name</code></b>: (Optional.) A name for the created operation.</li>
</ul>


<h4>Returns:</h4>

<p>A scalar <a href="../../../../tf/Tensor.html"><code>tf.Tensor</code></a> of type <a href="../../../../tf.html#string"><code>tf.string</code></a>.</p>
